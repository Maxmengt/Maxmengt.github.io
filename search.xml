<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[浅谈 HTML5 的大纲算法（HTML5 Outliner）]]></title>
      <url>%2F2016%2F11%2F22%2F%E6%B5%85%E8%B0%88-HTML5-%E7%9A%84%E5%A4%A7%E7%BA%B2%E7%AE%97%E6%B3%95%EF%BC%88HTML5-Outliner%EF%BC%89%2F</url>
      <content type="text"><![CDATA[写完这篇博客感觉 HTML5 的大纲算法就是大坑，很多地方的描述都是有所出入的，所以只能一切靠事实（实验）说话… 注：笔者在文末会介绍两种使 HTML 大纲可视化的方法，读者可以自行选择。 另：转载请注明出处… —— http://zhengboyang.com HTML4 的文档结构文档结构，即 &lt;body&gt; 标记之间内容的语义结构，对呈现页面给用户是很重要的。HTML4 用文档中章节和子章节的概念去描述文档结构。一个章节由一个包含着标题元素（h1-h6）的div元素表示。这些html划分元素（HTML Dividing Elements）和标题元素（HTML Heading Elements）形成了文档的结构和纲要。 优秀的文档结构，不单单有助于搜索引擎的优化（SEO），更是能为借助于屏幕阅读器浏览网页的盲人（或弱视力）用户提供巨大帮助。 而正如上面讲的，在HTML5出现之前，HTML4便是通过 h1-h6 的标题元素来创建大纲。在一般情况下，只要合理正确的使用标题元素，的确可以为文档赋予一个良好结构的大纲。 12345678910111213141516&lt;div class="section"&gt; &lt;h1&gt;HTML5 的文档节段和纲要&lt;/h1&gt; &lt;p&gt;HTML5新增了几个新元素使得开发者可以用标准语义去描述web文档的结构。&lt;/p&gt; &lt;div class="subsection"&gt; &lt;h2&gt;HTML4 的文档结构&lt;/h2&gt; &lt;p&gt;HTML4用文档中章节和子章节的概念去描述文档结构。&lt;/p&gt; &lt;div class="subsubsection"&gt; &lt;h3&gt;文档的结构和纲要&lt;/h3&gt; &lt;p&gt;划分元素（HTML Dividing Elements）和 标题元素（HTML Heading Elements）形成了文档的结构和纲要。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="section"&gt; &lt;h1&gt;HTML5 的音频和视频&lt;/h1&gt;&lt;div&gt; 该代码形成了如下大纲： 上述代码对于每一个章节使用了一个包含着标题元素的 div 元素来表示，可 div 元素其实并不表示定义一个章节（在这里的作用是使文档结构化），事实上一个新的 HTML 标题元素（HTML Heading Element）的出现就意味着产生了新的章节。 也就是说上述代码可以改成这样： 12345678&lt;h1&gt;HTML5 的文档节段和纲要&lt;/h1&gt;&lt;p&gt;HTML5新增了几个新元素使得开发者可以用标准语义去描述web文档的结构。&lt;/p&gt; &lt;h2&gt;HTML4 的文档结构&lt;/h2&gt; &lt;p&gt;HTML4用文档中章节和子章节的概念去描述文档结构。&lt;/p&gt; &lt;h3&gt;文档的结构和纲要&lt;/h3&gt; &lt;p&gt;这些html划分元素（HTML Dividing Elements）和 标题元素（HTML Heading Elements）形成了文档的结构和纲要。&lt;/p&gt;&lt;h1&gt;HTML5 的音频和视频&lt;/h1&gt; 检查发现其大纲并没有变化： 看起来还不错（笑 然而，HTML 4 的文档结构定义和其隐含的非常粗糙的大纲算法造成了很多问题： 由于 HTML4 实际上是以标题元素（h1-h6）作为章节的划分，并且标题元素的级别是其划分主副的关键，这也导致了文档间的合并变得十分困难。假如你要往一个主文档里合并子文档，那么就必须改变子文档里标题元素的级别（诸如将h1改为h2之类…）才能使文档大纲保持下来。而 HTML5 新引入的元素（&lt;article&gt;， &lt;section&gt;， &lt;nav&gt; 和 &lt;aside&gt;） 总是距离其最近的祖先章节的子章节， 与子文档章节内部的标题没有关系。 HTML4 中，所有的章节都是文档大纲中的一部分。但是文档并不总是这样，有些网站本身是聚合性质的，因此文档需要可以包含那些不属于大纲的章节，比如引用外来文档等。（HTML5 的 &lt;blockquote&gt;） 同样，HTML4 的大纲算法, 没有办法产生与网站相关而不是与文档相关的节段，比如 logos，menus，目录或版权信息和法律声明。（HTML5 的 &lt;header，&lt;footer&gt;） 可见，随着 HTML5 的应运而生，上述问题都在 HTML5 中得到了很好的解决。 HTML5 的大纲算法Defining sections and headings（节段与标题）&lt;body&gt; 元素定义了主节段，基于主节段，可以显式或隐式定义各个子节段的划分。显式定义的节段是通过&lt;body&gt;, &lt;section&gt;, &lt;article&gt;, &lt;aside&gt;, &lt;nav&gt; 这些标记中的内容。 （不包含 &lt;header&gt; 和 &lt;footer&gt;） 注：事实上 MDN 里的说法是包含了 &lt;header&gt; 和 &lt;footer&gt; 的，但经过其他文档的查阅以及自身实验，可以发现二者其实并不是节段元素。 HTML5 section 元素 (&lt;section&gt;) 表示文档中的一个区域（或节），比如，内容中的一个专题组。包括&lt;section&gt;，每种显式定义的节段一般都会包含一个标题（heading），通过是否包含标题（h1-h6）元素作为子节点来辨识每一个节段，其中，第一个 HTML 标题元素（&lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;, &lt;h6&gt;之一）定义了当前节段的标题。 值得注意的是，每个节段都可以有自己的标题结构，相关的标题级别只在节段中起作用。因此，即使是一个嵌套的 section 也能有 &lt;h1&gt;。 示例代码： 12345678910111213141516&lt;body&gt; &lt;section&gt; &lt;h1&gt;HTML5 的文档节段和纲要&lt;/h1&gt; &lt;p&gt;HTML5新增了几个新元素使得开发者可以用标准语义去描述web文档的结构。&lt;/p&gt; &lt;section&gt; &lt;h2&gt;HTML4 的文档结构&lt;/h2&gt; &lt;p&gt;HTML4用文档中章节和子章节的概念去描述文档结构。&lt;/p&gt; &lt;section&gt; 文档的结构和纲要 &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;section&gt; &lt;h1&gt;HTML5 的音频和视频&lt;/h1&gt; &lt;/section&gt;&lt;/body&gt; 生成大纲： 示例代码： 12345678910111213141516171819&lt;body&gt; &lt;h1&gt;HTML5 的大纲算法&lt;/h1&gt; &lt;section&gt; &lt;h1&gt;HTML5 的文档节段和纲要&lt;/h1&gt; &lt;p&gt;HTML5新增了几个新元素使得开发者可以用标准语义去描述web文档的结构。&lt;/p&gt; &lt;section&gt; &lt;h1&gt;HTML4 的文档结构&lt;/h1&gt; &lt;p&gt;HTML4用文档中章节和子章节的概念去描述文档结构。&lt;/p&gt; &lt;section&gt; &lt;h1&gt;文档的结构和纲要&lt;/h1&gt; &lt;p&gt;这些html划分元素（HTML sectioniding Elements）和 标题元素（HTML Heading Elements）形成了文档的结构和纲要。&lt;/p&gt; &lt;/section&gt; &lt;/section&gt; &lt;/section&gt; &lt;footer&gt; HTML5 的音频和视频 &lt;/footer&gt;&lt;/body&gt; 生成大纲： Implicit sectioning（隐式分节）说是隐式分节，其实主要目的就是为了与 HTML4 保持兼容，之前我们提到，在 HTML4 中一个新的 HTML 标题元素（&lt;h1&gt; - &lt;h6&gt;）的出现就意味着产生了新的章节，而这个性质在 HTML5 中保留了下来 —— 当其不是父节段第一个标题时，该方式将定义一个新的隐式节段（在不需要分节元素的情况下）。 这种隐式定义节段的方式跟其在父节点中与之前标题的相对级别有关： MDN中是这样说的： 如果比之前的标题级别更低，那么在节段里开始新的隐式子节段； 如果与前面标题的级别相同，那么闭合前面的节段（可能是显式标记的节段！）并开始新的同一级别的隐式节段； 如果比之前标题的级别更高，那么关闭之前的节段并开始新的这个更高级别的隐式节段。 然而经过我自己的尝试发现跟其描述有所出入（特别是第三点），不知道是 MDN 文档的问题还是 程序 HTML5 Outliner 的问题（在尝试了几款其他 HTML5 Outliner 后倾向于是 MDN 的问题）。 我试了不少样例，现在重新总结如下： 在同一显式节段内，并且比较时不包括前面其余显式定义的子节段，如果当前标题级别 如果当前标题级别比之前的标题级别更低，那么在前面节段（显式或隐式）里开始新的隐式子节段 如果当前标题级别与前面标题的级别相同，那么闭合前面的节段（显式或隐式）并开始新的同一级别的隐式节段 如果当前标题级别比之前标题的级别更高，那么闭合前面的节段（显式或隐式）并在当前所在显式节段内寻找小于等于自己的最高级别的标题，产生新的同一级别的隐式节段 可能有点绕… 示例代码： 123456789101112131415161718&lt;body&gt; &lt;h1&gt;HTML5 的大纲算法&lt;/h1&gt; &lt;section&gt; &lt;h3&gt;HTML5 的文档节段和纲要&lt;/h3&gt; &lt;section&gt; &lt;h2&gt;HTML4 的文档结构&lt;/h2&gt; &lt;!-- 当前标题级别比之前的标题级别更低 --&gt; &lt;h3&gt;HTML5 的音频和视频&lt;/h3&gt; &lt;/section&gt; &lt;!-- 当前标题级别与前面标题的级别相同 --&gt; &lt;h3&gt;定义节段和标题&lt;/h3&gt; &lt;section&gt; &lt;h3&gt;文档的结构和纲要&lt;/h3&gt; &lt;/section&gt; &lt;!-- 当前标题级别比之前标题的级别更高 --&gt; &lt;h1&gt;隐式节段&lt;/h1&gt; &lt;/section&gt;&lt;/body&gt; 生成大纲： Sectioning roots（虚节根）虚节根是一个HTML元素，这个元素可以拥有自己的大纲，但是元素内部的节段和标题对其祖先的大纲没有贡献。与文档的逻辑分节根&lt;body&gt;元素相比，这些元素经常在页面中引入外部内容：&lt;blockquote&gt;, &lt;details&gt;, &lt;fieldset&gt;, &lt;figure&gt; 和&lt;td&gt;。 示例代码： 123456789101112131415161718192021&lt;h1&gt;HTML5 的大纲算法&lt;/h1&gt;&lt;section&gt; &lt;h1&gt;HTML5 的文档节段和纲要&lt;/h1&gt; &lt;p&gt;HTML5新增了几个新元素使得开发者可以用标准语义去描述web文档的结构。&lt;/p&gt; &lt;section&gt; &lt;h1&gt;HTML4 的文档结构&lt;/h1&gt; &lt;p&gt;HTML4用文档中章节和子章节的概念去描述文档结构。&lt;/p&gt; &lt;section&gt; &lt;h1&gt;文档的结构和纲要&lt;/h1&gt; &lt;/section&gt; &lt;/section&gt; &lt;blockquote&gt; &lt;h1&gt;MDN&lt;/h1&gt; &lt;section&gt; &lt;h1&gt;Mozilla Foundation&lt;/h1&gt; &lt;/section&gt; &lt;/blockquote&gt;&lt;/section&gt;&lt;section&gt; &lt;h1&gt;HTML5 的音频和视频&lt;/h1&gt;&lt;/section&gt; 生成大纲： 显然，虽然 &lt;blockquote&gt; 里包含了 &lt;section&gt; 和 &lt;h1&gt; ，但在大纲中并无显示。 语义化HTML5 定义了一个新标签 &lt;main&gt;，规定文档的主要内容。&lt;main&gt; 元素中的内容对于文档来说应当是唯一的，在一个文档中，不能出现一个以上的 &lt;main&gt; 元素且&lt;main&gt; 元素不能是以下元素的后代：&lt;article&gt;、&lt;aside&gt;、&lt;header&gt;、&lt;footer&gt; 或 &lt;nav&gt;。 &lt;article&gt; 规定独立的自包含内容，一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发，比如论坛帖子、报纸文章、用户评论等。 &lt;aside&gt; 定义其所处内容之外的内容，它的内容应该与附近的内容相关，就像解释栏或广告栏。 &lt;header&gt; 定义了页面的头部，通常会包含 logo 和站点名称以及可能有的水平菜单。尽管名字是header，但是不一定是在页面的开始，比如可以包含在 &lt;article&gt; 的内部。 &lt;footer&gt; 定义了页脚，通常会包含版权信息和法律声明以及一些其他链接。同样，其不一定是在页面的底部出现，也可以包含在 &lt;article&gt; 的内部。 &lt;nav&gt; 定义的节段包含了很多导航links。文档中可以有好几个这样的元素，比如文档内部的链接，就像目录，和链接到其他站点的导航 links。 注：main 元素并不是一个节段，并不作为文档大纲的一部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt; &lt;header&gt;The Lawson Academy: &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="courses.html"&gt;Courses&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="fees.html"&gt;Fees&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;Graduation&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;main&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#ceremony"&gt;Ceremony&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#graduates"&gt;Graduates&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#awards"&gt;Awards&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;h2 id="ceremony"&gt;Ceremony&lt;/h2&gt; &lt;p&gt;Opening Procession&lt;/p&gt; &lt;p&gt;Speech by Valedictorian&lt;/p&gt; &lt;p&gt;Speech by Class President&lt;/p&gt; &lt;p&gt;Presentation of Diplomas&lt;/p&gt; &lt;p&gt;Closing Speech by Headmaster&lt;/p&gt; &lt;h2 id="graduates"&gt;Graduates&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Eileen Williams&lt;/li&gt; &lt;li&gt;Andy Maseyk&lt;/li&gt; &lt;li&gt;Blanca Sainz Garcia&lt;/li&gt; &lt;li&gt;Clara Faulkner&lt;/li&gt; &lt;li&gt;Gez Lemon&lt;/li&gt; &lt;li&gt;Eloisa Faulkner&lt;/li&gt; &lt;/ul&gt; &lt;h2 id="awards"&gt;Awards&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;Clara Faulkner&lt;/li&gt; &lt;li&gt;Eloisa Faulkner&lt;/li&gt; &lt;li&gt;Blanca Sainz Garcia&lt;/li&gt; &lt;/ul&gt; &lt;/main&gt; &lt;footer&gt; Copyright 2012 B.lawson&lt;/footer&gt;&lt;/body&gt; 生成大纲： 安装 HTML5 Outliner对于大纲的可视化，这里推荐两种办法。 一种是通过在线网址测试，在线网址功能繁多，支持上传 HTML 文件，填写 URL，以及粘贴 HTML 代码。 另一种方法是安装 Chrome 应用程序扩展，在应用商店搜索 HTML5 Outliner（Generates a navigable page outline with heading and sectioning elements.）并安装就可以了，功能比较单一，暂时只支持在线运行的网页。 总结HTML5 的大纲算法以及其引入的新元素显然更有助于 HTML 的语义化，但鉴于由于有些用户代理并没有完全支持 HTML5 ，因此在现实中最好做到标题级别与节段嵌套级别相匹配，保证标题的层级正确，方便节段在多个文档中的重用。 另外，由于本篇博文是笔者查阅相关文献后独自完成，难免会有所纰漏或考虑欠妥的地方，欢迎大家指正，非常感谢！ 参考文献Using HTML sections and outlines（感觉有不少描述是错误的/不严谨的…）4.3 Sections — HTML5The HTML5 Document Outline]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016 百度之星资格赛（Astar Round 1）]]></title>
      <url>%2F2016%2F05%2F20%2F2016-%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F%E8%B5%84%E6%A0%BC%E8%B5%9B-Astar-Round-1%2F</url>
      <content type="text"><![CDATA[最近不知道要刷什么题，刚好看到前几天的“百度之星”资格赛，便跑去做完了。 本文是2016年“百度之星”资格赛（Astar Round 1）所有题目的解题报告。 Problem A题目大意给定一个大字符串。有 $N$ 次询问，每次询问子串 $[L,R]$ 的哈希值 $H(s)$。一个字符串的哈希值定义为：$H(s)=\prod_{i=1}^{i\leq len(s)}(s_{i}-28)\ (mod\ 9973)$。$(1 \le N \le 1000$，$1 \le len(string) \le 10^5$，$1 \le L,R \le len(string))$ 解题思路预处理前缀+乘法逆元。 何谓乘法逆元？简单来讲，就是可以将除法取模转化为乘法：$(X \div Y)(mod\ P) = (X \times Y^{p-2})(mod\ P)$（当且仅当$P$为素数） 知道这个再预处理下前缀就做完了。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 10;const int MOD = 9973;char s[MAXN];int H[MAXN];int fast_pow(int x, int n)&#123; int res = 1; while( n ) &#123; if( n &amp; 1 ) res = res * x % MOD; x = x * x % MOD; n &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; int n; while( ~scanf("%d", &amp;n) ) &#123; scanf("%s", s + 1); int len = strlen(s + 1); H[0] = 1; for( int i = 1; i &lt;= len; ++ i ) &#123; H[i] = ((H[i - 1] * (s[i] - 28)) % MOD + MOD) % MOD; &#125; int a, b; while( n-- ) &#123; scanf("%d %d", &amp;a, &amp;b); printf("%d\n", H[b] * fast_pow(H[a - 1], MOD - 2) % MOD); &#125; &#125; return 0;&#125; Problem B题目大意给定一个全1序列。你可以合并任意相邻的两个1（只能是1），从而形成一个新的序列$(11-&gt;2)$，请计算根据以上方法，可以构成多少种不同的序列。题目输入一个 $N$，代表全1序列的长度，要求输出所能形成的新序列的数量。$(1 \le N \le 200)$ 解题思路递推+大数。 设 $dp[i]$ 表示长度为 $i$ 的全1序列所能形成的新序列的数量。 很容易算出 $dp[i] = dp[i - 1] + dp[i - 2]$。由于 $N$ 较大，本题需要用到大数。 解题代码1234567891011121314151617181920import java.util.*;import java.math.*;public class Main &#123; final static int MAXN = 200 + 10; public static void main(String[] args) &#123; BigInteger[] f = new BigInteger[MAXN]; f[1] = BigInteger.ONE; f[2] = BigInteger.valueOf(2); for( int i = 3; i &lt; MAXN; ++ i ) &#123; f[i] = f[i - 1].add(f[i - 2]); &#125; Scanner cin = new Scanner(System.in); while( cin.hasNext() ) &#123; int n = cin.nextInt(); System.out.println(f[n]); &#125; cin.close(); &#125;&#125;; Problem C题目大意度熊手上有一本神奇的字典，你可以在它里面做如下三个操作： $insert$ : 往神奇字典中插入一个单词 $delete$ : 在神奇字典中删除所有前缀等于给定字符串的单词 $search$ : 查询是否在神奇字典中有一个字符串的前缀等于给定的字符串 现共有 $N$ 次操作，题目要求对于每一个 $search$ 操作，如果在度熊的字典中存在给定的字符串为前缀的单词，则输出 $Yes$ 否则输出 $No$。$(1 \le N \le 10^5)$ 解题思路字典树。 理解题意后不难想到要用字典树，然后一开始对 $delete$ 操作我的想法是只让该点的儿子数组清空，这样对于 $search$ 操作由于其无法从该点继续往下走来实现删除功能。然而这样是有问题的，考虑这样几组操作： 3 insert helloworld delete hellow search hello 若按刚才所说只让该点的儿子数组清空，那么对于 $seach$ 操作将会输出 $Yes$，因为字典树可以走到 $o$ 结点，但是事实上从 $o$ 点出发的单词已经不存在了。因此可以在每个结点记录从该点出发的单词数量，维护下就可以了。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 10;const int MAXM = 26 + 10;struct Trie &#123; int cnt, sz[MAXN * 30][MAXM], num[MAXN * 30]; void init() &#123; cnt = 0; memset(sz[0], 0, sizeof(sz[0])); memset(num, 0, sizeof(num)); &#125; void insert(char *s) &#123; int len = strlen(s), now = 0; for( int i = 0; i &lt; len; ++ i ) &#123; if( !sz[now][s[i] - 'a'] ) &#123; sz[now][s[i] - 'a'] = ++cnt; memset(sz[cnt], 0, sizeof(sz[cnt])); &#125; num[now]++; now = sz[now][s[i] - 'a']; &#125; num[now]++; &#125; void del(char *s) &#123; int len = strlen(s), now = 0; for( int i = 0; i &lt; len; ++ i ) &#123; if( !sz[now][s[i] - 'a'] ) return ; now = sz[now][s[i] - 'a']; &#125; memset(sz[now], 0, sizeof(sz[now])); int m = num[now]; num[now] = 0; now = 0; for( int i = 0; i &lt; len; ++ i ) &#123; num[now] -= m; now = sz[now][s[i] - 'a']; &#125; &#125; bool search(char *s) &#123; int len = strlen(s), now = 0; for( int i = 0; i &lt; len; ++ i ) &#123; if( !sz[now][s[i] - 'a'] ) return false; now = sz[now][s[i] - 'a']; &#125; return num[now]; &#125;&#125; T;int main()&#123; int n; while( ~scanf("%d", &amp;n) ) &#123; char op[10], s[50]; T.init(); for( int i = 0; i &lt; n; ++ i ) &#123; scanf("%s %s", op, s); if( op[0] == 'i' ) &#123; T.insert(s); &#125; else if( op[0] == 'd' ) &#123; T.del(s); &#125; else if( op[0] == 's' ) &#123; printf("%s\n", T.search(s) ? "Yes" : "No"); &#125; &#125; &#125; return 0;&#125; Problem D题目大意题目规定字符串的所有全排列属于同个字符串。现给定 $N$ 个字符串，对于每个字符串输出前面出现过多少个相同的字符串。$(1 \le N \le 10^5)$ 解题思路map / hash。 将每个字符串按字典序排序再哈希一下，统计次数就可以了。 解题代码12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 10;map&lt;string, int&gt; mp;int main()&#123; int n; while( ~scanf("%d", &amp;n) ) &#123; mp.clear(); char s[50]; for( int i = 0; i &lt; n; ++ i ) &#123; scanf("%s", s); sort(s, s + strlen(s)); printf("%d\n", mp[s]); mp[s]++; &#125; &#125; return 0;&#125; Problem E题目大意给定 $N$ 个条件，条件可能是一个『简单条件』或者是一个『复合条件』。简单条件由『变量』、『比较符』和『运算数』组成，其中『变量』是用小写字符表示的一串字符（不同变量数量不会超过30个），『运算数』仅为整数，『运算符』包括：&lt;、&gt;、&lt;=、&gt;=、==。若干个『简单条件』中间通过英文逗号组成一个『复合条件』，各『简单条件』之间是逻辑与的关系。 题目要求对于第 $i$ 个条件，输出其与前 $i−1$ 个条件是否存在交集非空的情况。如果不存在交集非空的其他条件，输出一行字符串：『unique』。否则按照从小到大的顺序输出与其存在非空交集的条件的编号。$(1 \le N \le 1000)$ 解题思路逻辑题（？）。 个人感觉本题的难度主要是要看懂题目…题目的交集为空指的是两个条件相互矛盾。明白题意之后稍微理一下关系其实是很好写的。且题目 $N$ 只有 $1000$，不同变量的数量也不会超过30个，直接暴力 $O(N^2)$ 就可以了： 对于每个条件先看其本身是否矛盾，若不矛盾则存储该条件中所有变量的范围，然后与前面的条件 $check$ 下。 解题代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e3 + 10;const int INF = 0x3f3f3f3f;int m, ans[MAXN];map&lt;string, int&gt; mp;struct Con &#123; int L[MAXN], R[MAXN]; bool isValid; void init() &#123; for( int i = 1; i &lt;= 30; ++ i ) &#123; L[i] = -INF; R[i] = +INF; &#125; isValid = true; &#125; void insert(char *s, char *op, int num) &#123; if( !isValid ) return ; if( !mp[s] ) mp[s] = ++m; if( op[0] == '&gt;' ) &#123; if( op[1] == 0 ) L[mp[s]] = max(num + 1, L[mp[s]]); else L[mp[s]] = max(num, L[mp[s]]); &#125; else if( op[0] == '=' ) &#123; if( L[mp[s]] &gt; num || R[mp[s]] &lt; num ) isValid = false; L[mp[s]] = R[mp[s]] = num; &#125; else &#123; if( op[1] == 0 ) R[mp[s]] = min(num - 1, R[mp[s]]); else R[mp[s]] = min(num, R[mp[s]]); &#125; if( L[mp[s]] &gt; R[mp[s]] ) isValid = false; &#125;&#125; G[MAXN];int main()&#123; int n; scanf("%d", &amp;n); for( int i = 0; i &lt; n; ++ i ) &#123; G[i].init(); char s[30], op[10]; int num; scanf(" %[a-z] %[&gt;=&lt;] %d", s, op, &amp;num); G[i].insert(s, op, num); while( scanf(" , %[a-z] %[&gt;=&lt;] %d", s, op, &amp;num) &gt; 0 ) &#123; G[i].insert(s, op, num); &#125; if( !G[i].isValid ) &#123; puts("unique"); continue; &#125; int cnt = 0; for( int j = 0; j &lt; i; ++ j ) &#123; if( !G[j].isValid ) continue; bool isUnite = true; for( int k = 1; k &lt;= 30; ++ k ) &#123; if( G[i].L[k] &gt; G[j].R[k] || G[i].R[k] &lt; G[j].L[k] ) isUnite = false; &#125; if( isUnite ) ans[cnt++] = j + 1; &#125; for( int j = 0; j &lt; cnt; ++ j ) &#123; printf("%d%c", ans[j], " \n"[j == cnt - 1]); &#125; if( !cnt ) puts("unique"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Head First Python Web开发]]></title>
      <url>%2F2016%2F05%2F19%2FHead-First-Python-Web%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[本文是对《Head First Python》第7章 Web开发 的简单总结以及其中重要知识点的扩展介绍。 记笔记记笔记ing… CGI通用网关接口（Common Gateway Interface, CGI）是一种重要的互联网技术。CGI是外部应用程序（CGI程序）与Web服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的规程。（CGI程序：符合CGI标准的程序） CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器，CGI将Web的一组简单的静态超媒体文档变成一个完整的新的交互式媒体。 另外，编程语言Perl是一个广泛被用来编写CGI程序的语言，但CGI的一个目的是要独立于任何语言的。Web服务器无须在这个问题上对语言有任何了解。事实上，CGI程序可以用任何脚本语言或者是完全独立编程语言实现，只要这个语言可以在这个系统上运行。除Perl外，像Unix shell script, Python, Ruby, PHP, Tcl, C/C++,和Visual Basic都可以用来编写CGI程序。 MVC模型-视图-控制器（Model-View-Controller, MVC）是一种框架模式（非设计模式）。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。 模型：存储（以及有时处理）Web应用数据的代码。通常模型对象负责在数据库中存取数据。 视图：格式化和显示Web应用用户界面的代码。通常视图是依据模型数据创建的。 控制器：将Web应用“粘合”在一起并提供业务逻辑的代码。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 这里有一个通过 JavaScript 所实现的一个基础 MVC 模型，请注意的是：MVC 不是一种技术，仅是一种理念。 1234567891011121314// 模拟 Model, View, Controllervar M = &#123;&#125;, V = &#123;&#125;, C = &#123;&#125;;// Model 负责存放资料M.data = "hello world";// View 负责将资料输出到屏幕上V.render = function (M) &#123; alert(M.data); &#125;// Controller 作为一个 M 和 V 的桥梁C.handleOnload = function () &#123; V.render(M); &#125;// 在网页读取的时候呼叫 Controllerwindow.onload = C.handleOnload; Python PicklePython标准库的pickle模块可以容易而高效地将Python数据对象保存到磁盘以及从磁盘恢复。 Python的pickle模块实现了基本的数据序列和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，持久存储；通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。 pickle模块使用的数据格式是Python专用的，并且不同版本不向后兼容，同时也不能被其他语言所识别。（不同于关系数据库，这种方式恰恰满足了面向对象的封装性原则——即对象的数据只能通过这个对象自身的public接口来访问） pickle.dump()函数将数据保存到磁盘 1234import pickle ...with open('mydata.pickle', 'wb') as mysavedata: pickle.dump([1, 2, 'three'], mysavedata) pickle.load()函数从磁盘恢复数据 12345import pickle ...with open('mydata.pickle', 'rb') as myrestoredata: a_list = pickle.load(myrestoredata)print(a_list) 用Python构建Web服务器Python标准库http.server模块可以用来在Python中建立一个简单的Web服务器。123456from http.server import HTTPServer, CGIHTTPRequestHandler # 导入HTTP服务器和CGI模块port = 8080 # 指定一个端口httpd = HTTPServer(('', port), CGIHTTPRequestHandler) # 创建一个HTTP服务器print('Starting simple_httpd on port: ' + str(httpd.server_port))httpd.serve_forever() # 启动服务器 Python Template类Python标准库string模块包括一个名为Template的类，它支持简单的字符串替换。$substitute(mapping, kwds)$$safe_substitute(mapping, kwds)$123456789101112131415&gt;&gt;&gt; from string import Template&gt;&gt;&gt; s = Template('$who likes $what')&gt;&gt;&gt; s.substitute(who='tim', what='kung pao')'tim likes kung pao'&gt;&gt;&gt; d = dict(who='tim')&gt;&gt;&gt; Template('Give $who $100').substitute(d)Traceback (most recent call last):...ValueError: Invalid placeholder in string: line 1, col 11&gt;&gt;&gt; Template('$who likes $what').substitute(d)Traceback (most recent call last):...KeyError: 'what'&gt;&gt;&gt; Template('$who likes $what').safe_substitute(d)'tim likes $what' 使用Python的CGI模块来访问表单数据Python标准库CGI模块对编写CGI脚本提供了支持，可以使用cgi.FieldStorage()访问作为Web请求一部分发送给Web服务器的数据，数据将作为一个Python字典。1234import cgiform_data = cgi.FieldStorage()# name = 'which_athlete'athlete_name = form_data['which_athlete'].value # 从表单数据访问一个指定的数据 启用CGI跟踪来帮助解决错误CGI标准指出服务器端程序（CGI脚本）生成的任何输出都会由Web服务器捕获并发送到等待的Web浏览器。具体来说，会捕获发送到STDOUT（标准输出）的所有内容。 当CGI脚本产生异常时，Python将把错误消息显示在STDERR（标准错误输出）上。CGI机制会忽略这个输出，因为它想要的只是CGI脚本的标准输出。 令人欣喜的是，Python的标准库提供了一个CGI跟踪模块（cgitb），启用模块时，会在Web浏览器上显示详细的错误消息。12import cgitbcgitb.enable() # 打开cgi跟踪 使用Python的glob模块处理文件名列表Python标准库glob模块非常适合处理文件名列表，用它可以查找符合特定规则的文件路径名。类似windows下的文件搜索功能。 glob查找文件只用到三个匹配符：”*“, “?”, “[]”： “*” 匹配0个或多个字符 “?” 匹配单个字符 “[]” 匹配指定范围内的字符 $glob.glob(pathname)$ pathname can be either absolute or relative123456&gt;&gt;&gt; import glob&gt;&gt;&gt; files = glob.glob(r"E:/*.txt")&gt;&gt;&gt; files['E:/apekk Lisk.txt', 'E:/apr License.txt', 'E:/Changelog-pre1.8.txt', 'E:/Changelog.txt', 'E:/githelp.txt', 'E:/TortoiseGit License.txt']&gt;&gt;&gt; type(files)&lt;class 'list'&gt; $glob.iglob(pathname)$ pathname can be either absolute or relative1234567891011121314&gt;&gt;&gt; import glob&gt;&gt;&gt; files = glob.iglob(r"E:/*.txt")&gt;&gt;&gt; files&lt;generator object iglob at 0x000000000319C3A8&gt;&gt;&gt;&gt; type(files)&lt;class 'generator'&gt;&gt;&gt;&gt; for file in files: print(file)E:/apekk Lisk.txtE:/apr License.txtE:/Changelog-pre1.8.txtE:/Changelog.txtE:/githelp.txtE:/TortoiseGit License.txt 官方文档里是这样描述 $iglob$ 与 $glob$ 的区别的： iglob() return an iterator which yields the same values as glob() without actually storing them all simultaneously.已经说得很明白了所以不再赘述。 完。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈差分约束系统与SPFA算法]]></title>
      <url>%2F2016%2F05%2F17%2F%E6%B5%85%E8%B0%88%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%E4%B8%8ESPFA%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[鉴于今天做到了差分约束的题目，那么也顺便简单总结一下差分约束的基本求解思路，以及 $SPFA$ 算法的两个优化与如何通过 $SPFA$ 求最长路。 差分约束系统一般来说，对于一类“两个未知数的差小于等于（或大于等于）某个常数” $(x_i - x_j \le c)$ 不等式组的求解，便是差分约束系统。差分约束系统的美妙之处在于可以将其转为图论，通过求解单源最短路来判断原不等式组是否有解甚至求得最大或最小解。 首先，显然对于此类不等式组，要么无解，要么有无数解。因为假设存在一组解为 ${x_1, x_2, …, x_n}$，那么对于任意一个常数 $k$，${x_1 + k, x_2 + k, …, x_n + k}$ 也必是一组解，因为他们的差值是不变的，所以不等式组依然成立。 接下来考虑单源最短路图，对于某点 $v$ 与其邻接点 $u$，显然 $dist[v] \le dist[u] + cost_{u-&gt;v}$，也即 $dist[v] - dist[u] \le cost_{u-&gt;v}$，正好满足“两个未知数的差小于等于某个常数”。因此，我们将待求解不等式组中的未知数看成图上的顶点，对于每个不等式 $x_i - x_j \le c$，转化成图中顶点 $i$ 向 $j$ 建边，边权为 $c$。 然后直接在建成的图上跑单源最短路就可以了。如果存在负环则无解，否则 ${dist[i]}$ 便是其中一组解，至于以哪个点作为源点都是可以的。相当于以哪个点作为源点就是将该点赋值为 $0$，通过该约束去得出不等式组中其他未知数的解。 还有一种是不仅需要判断是否有解，还要求求出一组最大/最小解，这种类型可以考虑通过增加一个点去对其他点进行约束，然后以这个点为源点跑最长/最短路求解，由于差分约束类型题目近几年几乎不可见了，所以基本没遇过这种类型，只能瞎BB下。 SPFA 算法由于图中可能存在负环，所以不能使用 $dijkstra$ 算法求解，可以考虑使用 $SPFA$ 或者 $Bellman-Ford$，个人建议用 $SPFA$ ，比较快。 最长路与最短路$SPFA$ 求最长路的算法跟求最短路类似： 最长路是初始化为 $0$，当存在 $dist[v] &lt; dist[u] + cost_{u-&gt;v}$ 时进行更新。 最短路时初始化为 $INF$，当存在 $dist[v] &gt; dist[u] + cost_{u-&gt;v}$ 时进行更新。 SPFA的优化另外，有时连 $SPFA$ 算法的玄学时间复杂度都不能承受，可以考虑使用 $SPFA$ 的两个优化：$SLF$ 和 $LLL$。 $SLF$: $Small$ $Label$ $First$ 使用双端队列$deque$，把将要插入的节点 $v$ 与此时队列中的队首 $u$ 的 $dist$ 进行比较，若小于则插入队首，否则插入队尾。即优先将 $dist$ 较小的节点拿出来松弛操作。 $LLL$: $Large$ $Label$ $Last$ 讲道理这种优化我也没用到过(。・・)ノ。不过还是简单讲下，这种方法需要维护队列中 $dist$ 的平均值，然后每次出队时（设为 $i$），将 $dist[i]$ 与 $dist_{avg}$ 进行比较，若大于则将 $i$ 节点重新插入队尾，然后继续出队，一直找到一个节点使得 $dist[i] \le dist_{avg}$，将其取出进行松弛操作。 等有空再来补几发代码。 完。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 4276 The Ghost Blows Light（树型DP）]]></title>
      <url>%2F2016%2F05%2F17%2Fhdu-4276%2F</url>
      <content type="text"><![CDATA[题目大意给定一棵 $N$ 个节点的树，点上有价值为 $A_i$，边上有时间花费 $t_j$。要求从编号 $1$ 的节点出发，到达编号为 $N$ 的节点，问是否能在给定的 $T$ 时间里到达，若能，输出可以获得的最大价值。每个节点的价值只能算一次，但边每走一次都得消耗时间。$(1 \le n \le 100, 0 \le T \le 500, 0 \le A_i \le 100, 0 \le t_j \le 100)$ 解题思路树型DP。 先 DFS 算出从 $1$ 号点到 $N$ 号点的最小花费，若大于时间 $T$ 直接输出。否则将之前 DFS 到的路径上的花费赋为 $0$，然后直接 树型DP 就可以了。 $dp[i][j]$ 表示在 $i$ 点花费时间 $j$ 所能获得的最大价值。由于必走路径上的花费已赋为 $0$，那么 $dp$ 时必会取到路径上节点的价值。然后状态方程转移的原理类似于01背包，只不过多了一层枚举子节点花费多少时间，这是跟普通01背包不同的地方，普通01背包是固定花费多少价值多少，而这里是枚举花费多少价值多少。 详细请看代码。 Ps: DP还是太弱啦QAQ，以后DP还是得多做点题目。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e2 + 10;struct Edge &#123; int to, cost, next; Edge( int to = 0, int cost = 0, int next = 0 ) : to(to), cost(cost), next(next) &#123;&#125;&#125; G[MAXN &lt;&lt; 1];int n, T;int a[MAXN];int tot, head[MAXN];int dp[MAXN][MAXN &lt;&lt; 3];void init()&#123; tot = 0; memset(head, -1, sizeof(head));&#125;void addEdge(int u, int v, int cost)&#123; G[tot] = Edge(v, cost, head[u]); head[u] = tot++; G[tot] = Edge(u, cost, head[v]); head[v] = tot++;&#125;int findPath(int u, int pre, int cost)&#123; if( u == n ) return cost; for( int i = head[u]; ~i; i = G[i].next ) &#123; Edge &amp;e = G[i]; if( e.to == pre ) continue; int d = findPath(e.to, u, cost + e.cost); if( d ) &#123; e.cost = 0; G[i ^ 1].cost = 0; return d; &#125; &#125; return 0;&#125;void dfs(int u, int pre)&#123; fill(dp[u], dp[u] + T + 1, a[u]); for( int i = head[u]; ~i; i = G[i].next ) &#123; Edge &amp;e = G[i]; if( e.to == pre ) continue; int temp = e.cost &lt;&lt; 1; dfs(e.to, u); for( int j = T; j &gt;= temp; -- j ) &#123; // 倒序枚举，原理同一维01背包 for( int k = temp; k &lt;= j; ++ k ) &#123; dp[u][j] = max(dp[u][j], dp[u][j - k] + dp[e.to][k - temp]); &#125; &#125; &#125;&#125;int main()&#123; while( ~scanf("%d %d", &amp;n, &amp;T) ) &#123; init(); int x, y, t; for( int i = 0; i &lt; n - 1; ++ i ) &#123; scanf("%d %d %d", &amp;x, &amp;y, &amp;t); addEdge(x, y, t); &#125; for( int i = 1; i &lt;= n; ++ i ) &#123; scanf("%d", a + i); &#125; int cost = findPath(1, -1, 0); if( cost &gt; T ) &#123; puts("Human beings die in pursuit of wealth, and birds die in pursuit of food!"); continue; &#125; T -= cost; dfs(1, -1); printf("%d\n", dp[1][T]); &#125; return 0;&#125; 知识扩展 01背包：先枚举物品，再逆序枚举容量 完全背包：先枚举物品，再正序枚举容量 分组背包：先逆序枚举容量，再枚举物品（最外层枚举每一组）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UVALive 5094 THE MATRIX PROBLEM（差分约束）]]></title>
      <url>%2F2016%2F05%2F17%2Fuvalive-5094%2F</url>
      <content type="text"><![CDATA[题目大意给定一个 $N \times M$ 的矩阵 $E_{i,j}$。问是否存在一组解 $N$ 个数 $a_1, a_2, …, a_N$ 与 $M$ 个数 $b_1, b_2, …, b_M$ 满足对矩阵的每个元素使 $E_{i,j}$ = $E_{i,j} \times a_i \div b_j$ 后，值大小的范围为 $[L,U]$。输出 $YES$ 或 $NO$。$(1 \le N, M \le 400, 1 \le L \le U \le 10000)$ 解题思路差分约束。 观察 $L / E_{i,j} \le a_i \div b_j \le U / E_{i,j}$，对于不等式组判断容易想到差分约束系统。 然而差分约束系统主要是针对“两个未知数的差小于等于（或大于等于）某个常数”的。因此可以考虑对不等式取 $log$，把除法转为减法，即 $log(L / E_{i,j}) \le log(a) - log(b) \le log(U / E_{i,j})$，接着跑 $spfa$ 就可以啦。 另外，本题 $spfa$ 需要使用双端队列优化下（$SLF$: Small Label First）。代码中注释部分使用的是“栈优化”，感觉这种优化方式还是有点奇怪的，本题能过（不TLE）可能是因为数据的关系，总之不推荐… 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 4e2 + 10;const int MAXM = 4e5 + 10;const int INF = 0x7fffffff;struct Edge &#123; int to; double cost; int next; Edge( int to = 0, double cost = 0, int next = 0 ) : to(to), cost(cost), next(next) &#123;&#125;&#125; G[MAXM];int n, m, E[MAXN][MAXN];int tot, head[MAXN &lt;&lt; 1];double d[MAXN &lt;&lt; 1];int cnt[MAXN &lt;&lt; 1], st[MAXM];bool inque[MAXN &lt;&lt; 1];void init()&#123; tot = 0; memset(head, -1, sizeof(head)); memset(inque, 0, sizeof(inque)); memset(cnt, 0, sizeof(cnt));&#125;void addEdge(int u, int v, double cost)&#123; G[tot] = Edge(v, cost, head[u]); head[u] = tot++;&#125;// bool spfa(int s)// &#123;// int top = 0;// fill(d, d + n + m + 1, INF);// d[s] = 0;// st[top++] = s;// inque[s] = true;// cnt[s] = 1;// while( top ) &#123;// int u = st[--top];// inque[u] = false;// for( int i = head[u]; ~i; i = G[i].next ) &#123;// Edge &amp;e = G[i];// if( d[e.to] &gt; d[u] + e.cost ) &#123;// if( ++cnt[e.to] &gt; n + m + 1 ) &#123;// return false;// &#125;// d[e.to] = d[u] + e.cost;// if( !inque[e.to] ) &#123;// st[top++] = e.to;// inque[e.to] = true;// &#125;// &#125;// &#125;// &#125;// return true;// &#125;bool spfa(int s)&#123; fill(d, d + n + m + 1, INF); d[s] = 0; deque&lt;int&gt; dque; dque.push_back(s); inque[s] = true; cnt[s] = 1; while( !dque.empty() ) &#123; int u = dque.front(); dque.pop_front(); inque[u] = false; for( int i = head[u]; ~i; i = G[i].next ) &#123; Edge &amp;e = G[i]; if( d[e.to] &gt; d[u] + e.cost ) &#123; if( ++cnt[e.to] &gt; n + m + 1 ) return false; d[e.to] = d[u] + e.cost; if( !inque[e.to] ) &#123; if( dque.empty() || d[e.to] &gt; d[dque.front()] ) dque.push_back(e.to); else dque.push_front(e.to); inque[e.to] = true; &#125; &#125; &#125; &#125; return true;&#125;int main()&#123; int L, U; while( ~scanf("%d %d %d %d", &amp;n, &amp;m, &amp;L, &amp;U) ) &#123; init(); for( int i = 1; i &lt;= n; ++ i ) &#123; for( int j = 1; j &lt;= m; ++ j ) &#123; scanf("%d", &amp;E[i][j]); addEdge(j + n, i, log(U * 1.0 / E[i][j])); addEdge(i, j + n, log(E[i][j] * 1.0 / L)); &#125; &#125; int s = 0; for( int i = 1; i &lt;= n; ++ i ) addEdge(s, i, 0); for( int j = 1; j &lt;= m; ++ j ) addEdge(s, j + n, 0); if ( spfa(s) ) puts("YES"); else puts("NO"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[POJ 3764 The xor-longest Path（字典树）]]></title>
      <url>%2F2016%2F05%2F15%2Fpoj-3764%2F</url>
      <content type="text"><![CDATA[题目大意给定一棵 $N$ 个点的赋权树，要求异或和最大的路径。输出最大异或和。$(1 \le n \le 10^5, 0 \le w \le 2^{31})$ 解题思路字典树 + 贪心。 首先由于是一棵树，也即点两两之间的路径使唯一的。 接着考虑异或的性质，异或运算满足交换律、结合律。由此得： $(x \oplus y) \oplus y = x \oplus (y \oplus y) = x$， $(x \oplus a) \oplus (y \oplus a) = x \oplus y$ 。 因此，对于两点 $x,y$ 之间路径的异或和，会等于 $x$ 到另外一个节点 $a$ 的异或和 与 $y$ 到 $a$ 的异或和的异或。 因此先以任意点作为根节点dfs，得到每个点到根节点的异或和。这样问题就转化为“给定 $N$ 个数，求两两之间的最大异或值”。对于本题显然 $O(N^2)$ 是过不了的，而如果使用字典树便可以在 $O(N * 32)$ 接近 $O(N)$ 的时间得到答案。 由于权值 $w \le 2^{31}$，对于求异或有效位只有31位，我们对于每个数从高位向低位建树，将所有的异或值保存起来。然后询问时尽量（贪心）走相反的路径（使该位异或为 $1$），使得最大异或和尽量大。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 10;const int MAXM = 1e6;const int MAXS = 2;struct Edge &#123; int to, cost, next; Edge( int to = 0, int cost = 0, int next = 0 ) : to(to), cost(cost), next(next) &#123;&#125;&#125; G[MAXN &lt;&lt; 1];int n;int tot, head[MAXN];int dp[MAXN];struct Trie &#123; int cnt, sz[MAXN * 32][MAXS]; void init() &#123; cnt = 0; sz[0][0] = sz[0][1] = 0; &#125; void insert(int va) &#123; int now = 0; for( int i = 30; i &gt;= 0; -- i ) &#123; int index = va &gt;&gt; i &amp; 1; if( !sz[now][index] ) &#123; sz[now][index] = ++cnt; sz[cnt][0] = sz[cnt][1] = 0; &#125; now = sz[now][index]; &#125; &#125; int query(int va) &#123; int now = 0, ans = 0; for( int i = 30; i &gt;= 0; -- i ) &#123; int index = !(va &gt;&gt; i &amp; 1); if( sz[now][index] ) &#123; ans |= 1 &lt;&lt; i; now = sz[now][index]; &#125; else &#123; now = sz[now][!index]; &#125; &#125; return ans; &#125;&#125; T;void init()&#123; tot = 0; memset(head, -1, sizeof(head));&#125;void addEdge(int u, int v, int cost)&#123; G[tot] = Edge(v, cost, head[u]); head[u] = tot++; G[tot] = Edge(u, cost, head[v]); head[v] = tot++;&#125;void dfs(int u, int pre, int xo)&#123; dp[u] = xo; for( int i = head[u]; ~i; i = G[i].next ) &#123; Edge &amp;e = G[i]; if( e.to == pre ) continue; dfs(e.to, u, xo ^ e.cost); &#125;&#125;int main()&#123; while( ~scanf("%d", &amp;n) ) &#123; init(); int u, v, w; for( int i = 0; i &lt; n - 1; ++ i ) &#123; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); &#125; dfs(0, -1, 0); T.init(); int Max = 0; for( int i = 0; i &lt; n; ++ i ) &#123; Max = max(Max, T.query(dp[i])); T.insert(dp[i]); &#125; printf("%d\n", Max); &#125; return 0;&#125; 解题总结 RE了好多发…后来发现是第30行写搓了，写成了 int index = v &amp; (1 &lt;&lt; i); …以后统一换成这种写法： v &gt;&gt; i &amp; 1。 要学会判断字典树数组要开多大。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Codeforces Gym Hello 2015 B Troynacci Query（partial sum）]]></title>
      <url>%2F2016%2F05%2F07%2FCodeforces-Gym-Hello-2015-(Div-2)-B%2F</url>
      <content type="text"><![CDATA[题目大意定义函数 $f(x)$：给定 $f(1),f(2)$，当 $i &gt; 2，f(i) = af(i - 2) + bf(i - 1) $ 。现给定一个长度为 $n$ 的序列 $x_i$，一共有 $q$ 次操作。每次操作子序列 $[l,r]$，对于每个 $x_i(l \le i \le r)$， 增加 $f(i-l+1)$。求最终序列。$(1 \le n, q \le 10^5, 1 \le f(1),f(2),a,b \le 10^9,0 \le x_i \le 10^9)$ 解题思路Partial sum。 考虑问题的简化版本，同样给定一个长度为 $n$ 的序列，同样有 $q$ 次操作，只不过每次操作对于每个 $x_i(l \le i \le r)$， 增加的是一个定值 $v$。 假设数据范围是一样的，这时要怎么求解呢？ 可能有些人会想到用线段树或者RMQ，复杂度为 $O(nlogn)$。然而实际上这种题目有更快的称为 partial sum 的 $O(n)$ 解法（如下）： 维护一个新的数组 $p_1, p_2,…, p_n$，一开始初始化为 $0$，然后对于每次操作 $[l,r]$，使 $p[l]$ 增加 $v$ ，使 $p[r + 1]$ 减少 $v$。所有操作结束后，对于每一个 $i$，从 $1$ 开始，使 $p[i] = p[i] + p[i - 1]$ 。那么最终答案序列就是 $x_1 + p_1, x_2 + p_2, …, x_n + p_n$ 。 算法原理还是很容易理解的，这里就不再赘述了。 那么回到一开始的问题，此时对于 $[l,r]$ 增加的不再是一个定值 $v$。但是可以发现， $f(i)$ 是一个递推求解的函数。而且，对于 $p_i = f[a] + f[b] + f[c] + …$ ，满足 $p_{i+1} = f[a + 1] + f[b + 1] + f[c + 1] + … = ap_{i-1} + bp_{i}$ 。发现这个，问题就基本解决了，另外由于 $f(1),f(2)$ 本身并不满足递推式，需要特殊处理（细节请看代码：多多揣摩）。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;typedef long long ll;const int MAXN = 1e5 + 10;const int MOD = 1e9 + 7;int n, q;ll a, b, x[MAXN], f[MAXN], s[MAXN];void init()&#123; memset(s, 0, sizeof(s)); for( int i = 3; i &lt; MAXN; ++ i ) &#123; f[i] = (a * f[i - 2] + b * f[i - 1]) % MOD; &#125;&#125;int main()&#123; init(); while( std::cin &gt;&gt; n &gt;&gt; q ) &#123; std::cin &gt;&gt; f[1] &gt;&gt; f[2] &gt;&gt; a &gt;&gt; b; init(); for( int i = 1; i &lt;= n; ++ i ) std::cin &gt;&gt; x[i]; int l, r; while( q-- ) &#123; std::cin &gt;&gt; l &gt;&gt; r; (s[l] += f[1]) %= MOD; if( r - l &gt;= 1 ) &#123; (s[l + 1] += f[2]) %= MOD; s[l + 1] = ((s[l + 1] - b * f[1]) % MOD + MOD) % MOD; s[r + 1] = (s[r + 1] + MOD - f[r - l + 2]) % MOD; s[r + 2] = ((s[r + 2] - a * f[r - l + 1]) % MOD + MOD) % MOD; &#125; else &#123; s[r + 1] = ((s[r + 1] - b * f[1]) % MOD + MOD) % MOD; s[r + 2] = ((s[r + 2] - a * f[1]) % MOD + MOD) % MOD; &#125; &#125; for( int i = 1; i &lt;= n; ++ i ) &#123; if( i &gt;= 2 ) (s[i] += a * s[i - 2]) %= MOD; (s[i] += b * s[i - 1]) %= MOD; (x[i] += s[i]) %= MOD; &#125; for( int i = 1; i &lt;= n; ++ i ) &#123; std::cout &lt;&lt; x[i] &lt;&lt; " "; &#125; std::cout &lt;&lt; std::endl; &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Codeforces Round 349 B World Tour（最短路 + 枚举）]]></title>
      <url>%2F2016%2F05%2F04%2FCodeforces-Round-349-(Div-1)-B%2F</url>
      <content type="text"><![CDATA[题目大意给定一个 $N$ 个点，$M$ 条边的有向图。现将选择 $4$ 个不同的点进行顺序访问（从第 $1$ 个点出发，在第 $4$ 个点结束），并满足点与点之间的最短路距离之和最大。输出符合条件的任意 $4$ 个点。注意可多次经过同一个点。$(4 \le n \le 3000, 3 \le m \le 5000)$ 解题思路最短路+枚举。 先跑最短路，计算 $f(u,v)$ 表示 $u$ 到 $v$ 的最短路。 对于所求问题 $a \to b \to c \to d$，枚举 $b$ 和 $c$，之后枚举 $f(a,b)$ 中最大的 $3$ 个 $a$，和 $f(c,d)$ 中最大的 $3$ 个 $d$（跑最短路时可以预处理出 $3$ 个最大的点），check一下就可以了。 为什么只需要枚举最大的 $3$ 个点就可以呢？考虑对 $f(a,b)$ 中 $a$ 的枚举，由于 $a \notin {b, c, d}$，所以 $a$ 的不合法取值只有 $3$ 个，且预处理时可以保证 $a \ne b$，所以 $a$ 可能的取值只有 $f(x,b)$ 中最大的 $3$ 个 $x$。枚举 $d$ 同理。 官方题解： You are given the oriented graph, find four distinct vertices a, b, c, d such that each vertex if reachable from previous and the sum of shortest paths between consequitive vertices is as large as possible. First let’s run a BFS from each vertex and find three most distant vertices over given graph and its reverse. Afterwards loop through each possible b and c. Having them fixed, loop through a among three most distant vertices from b in the reversed graph and through d among three most distant vertices from c in tie initial graph. This is sufficient, because if we’ve fixed b and c and d is not one of three furthest from c then we could replace it with one of them and improve the answer. 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;const int MAXN = 3e3 + 10;const int MAXM = 5e3 + 10;int n, m;int dist[MAXN][MAXN];vector&lt;int&gt; G[MAXN];vector&lt;P&gt; maze[MAXN], rmaze[MAXN];void bfs(int s)&#123; memset(dist[s], -1, sizeof(dist[s])); queue&lt;int&gt; que; que.push(s); dist[s][s] = 0; while( !que.empty() ) &#123; int u = que.front(); que.pop(); for( int i = 0; i &lt; G[u].size(); ++ i ) &#123; int v = G[u][i]; if( dist[s][v] == -1 ) &#123; dist[s][v] = dist[s][u] + 1; que.push(v); &#125; &#125; &#125;&#125;int main()&#123; while( ~scanf("%d %d", &amp;n, &amp;m) ) &#123; int u, v; for( int i = 0; i &lt; m; ++ i ) &#123; scanf("%d %d", &amp;u, &amp;v); G[u].push_back(v); &#125; for( int i = 1; i &lt;= n; ++ i ) bfs(i); for( int i = 1; i &lt;= n; ++ i ) &#123; for( int j = 1; j &lt;= n; ++ j ) &#123; if( i == j || dist[i][j] == -1 ) continue; maze[i].push_back(P(dist[i][j], j)); rmaze[j].push_back(P(dist[i][j], i)); &#125; sort(maze[i].begin(), maze[i].end(), greater&lt;P&gt;()); if( maze[i].size() &gt; 3 ) maze[i].resize(3); &#125; for( int i = 1; i &lt;= n; ++ i ) &#123; sort(rmaze[i].begin(), rmaze[i].end(), greater&lt;P&gt;()); if( rmaze[i].size() &gt; 3 ) rmaze[i].resize(3); &#125; int A, B, C, D, Max = 0; for( int b = 1; b &lt;= n; ++ b ) &#123; for( int c = 1; c &lt;= n; ++ c ) &#123; if( b == c || dist[b][c] == -1 ) continue; for( int i = 0; i &lt; rmaze[b].size(); ++ i ) &#123; int a = rmaze[b][i].second; if( a == c ) continue; for( int j = 0; j &lt; maze[c].size(); ++ j ) &#123; int sum = dist[a][b] + dist[b][c]; int d = maze[c][j].second; if( a == d || b == d ) continue; sum += dist[c][d]; if( sum &gt; Max ) &#123; Max = sum; A = a, B = b, C = c, D = d; &#125; &#125; &#125; &#125; &#125; printf("%d %d %d %d\n", A, B, C, D); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[UESTC 1220 The Battle of Guandu（最短路）]]></title>
      <url>%2F2016%2F04%2F14%2Fuestc-1220%2F</url>
      <content type="text"><![CDATA[题目大意背景：曹操和袁绍在官渡决战。现有 $N$ 个村庄， $M$ 个战场。对于村庄 $i$ ，曹操可以挑选一些人去给定的 $x_i$ 战场充军（曹操军队），每挑选一个人需要花费 $c_i$ 元。由于村子的人惧怕袁绍的报复，所以村庄会送相同数量的人去给定的 $y_i$ 战场充军（袁绍军队）。每个战场都有一个重要性 $w_i$。为了保证曹操的胜利，重要性为 $2$ 的战场曹操军队士兵数量要严格多于袁绍，重要性为 $1$ 的战场曹操军队士兵数量不能少于袁绍，重要性为 $0$ 的战场则无所谓。一开始双方都没有军队，问为保证胜利，曹操需要花费的最小费用。无解输出 $-1$。$(1 \leq N, M \leq 10^5，1 \leq x_i, y_i \leq 10^5，0 \leq c_i \leq 10^5，w_i \in {0, 1, 2})$ 时限 $3s$。 解题思路最短路。 一个巧妙的想法是只考虑己方军队（曹操）。那么每次挑选相当于从 $y_i$ 战场向 $x_i$ 战场送兵。由于 $0$ 战场（重要性为 $0$） 不用考虑胜负，所以军队士兵的最终来源一定是 $0$ 战场， $1$ 战场只能作为中间点过度。由此进行建图： 源点 $s$ 向所有 $0$ 战场连一条费用为 $0$ 的有向边 $y_i$ 战场向 $x_i$ 战场连一条费用为 $c_i$ 的有向边 直接跑单源最短路，然后将所有 $2$ 战场的权值加起来便是答案了。（若有一个不能到达则输出 $-1$）。 Ps: 是道好题，6rz出题人。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 10;struct Edge &#123; int to, cost, next; Edge( int to = 0, int cost = 0, int next = 0 ) : to(to), cost(cost), next(next) &#123;&#125;&#125; G[MAXN &lt;&lt; 1];int n, m;int tot, head[MAXN];int x[MAXN], y[MAXN], c[MAXN], w[MAXN];bool inque[MAXN];ll d[MAXN];void init()&#123; tot = 0; memset(head, -1, sizeof(head));&#125;void readData(int* v, int num)&#123; for( int i = 0; i &lt; num; ++ i ) scanf("%d", v + i);&#125;void readAll()&#123; readData(x, n); readData(y, n); readData(c, n); readData(w, m);&#125;void addEdge(int u, int v, int cost)&#123; G[tot] = Edge(v, cost, head[u]); head[u] = tot++;&#125;void mapping()&#123; for( int i = 0; i &lt; m; ++ i ) &#123; if( !w[i] ) addEdge(0, i + 1, 0); &#125; for( int i = 0; i &lt; n; ++ i ) &#123; addEdge(y[i], x[i], c[i]); &#125;&#125;ll spfa(int s)&#123; memset(d, -1, sizeof(d)); queue&lt;int&gt; que; d[s] = 0; inque[s] = true; que.push(s); while( !que.empty() ) &#123; int u = que.front(); que.pop(); inque[u] = false; for( int i = head[u]; ~i; i = G[i].next ) &#123; Edge&amp; e = G[i]; if( d[e.to] == -1 || d[e.to] &gt; d[u] + e.cost ) &#123; d[e.to] = d[u] + e.cost; if( !inque[e.to] ) que.push(e.to); inque[e.to] = true; &#125; &#125; &#125; ll ans = 0; for( int i = 0; i &lt; m; ++ i ) &#123; if( w[i] == 2 ) &#123; if( d[i + 1] == -1 ) &#123; ans = -1; break; &#125; ans += d[i + 1]; &#125; &#125; return ans;&#125;int main()&#123; int T, cas = 0; scanf("%d", &amp;T); while( T-- ) &#123; init(); scanf("%d %d", &amp;n, &amp;m); readAll(); mapping(); ll ans = spfa(0); printf("Case #%d: ", ++cas); if( ~ans ) printf("%lld\n", ans); else puts("-1"); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FZU 2143 Board Game（费用流）]]></title>
      <url>%2F2016%2F04%2F13%2Ffzu-2143%2F</url>
      <content type="text"><![CDATA[题目大意给定一个 $N \times M$ 的矩阵 $A$ 和数字 $k$。你有一个零矩阵 $B$，每次可以将矩阵 $B$ 中任意两个相邻元素（上下或左右）同时加 $1$，可以任意操作多次，但元素最大值不能超过 $k$。求以下表达式的最小值： $$S = \sum_{i-1}^{N}\sum_{j-1}^{M}(A_{ij} - B_{ij})^{2} $$$(1 \leq N, M, K \leq 9 )$ 时限 $1s$。 解题思路最小费用流。 观察公式可知，对于某个元素加 $1=&gt;B_{ij}$，其 $S$ 增加了 $2 B_{ij} - 2 A_{ij} - 1 $。将 $B_{ij}$ 当成变量的话，显然该函数式是单调递增的。 由此我们以棋盘模型进行建图（在标准的棋盘上，通常把交替地着上黑色和白色） ： 源点 $s$ 向黑色方格连 $k$ 条容量为 $1$，费用为 $2 x - 2 A_{ij} - 1(1 \leq x \leq k)$ 的边 黑色方格向相邻的白色方格连 $1$ 条容量为 $\infty$ ，费用为 $0$ 的边 白色方格向汇点 $t$ 连 $k$ 条容量为 $1$，费用为 $2 x - 2 A_{ij} - 1(1 \leq x \leq k)$ 的边 然后跑最小费用流（非最大流），当到汇点 $t$ 的增广路的距离 $d[t] \geq 0$ 时，不再进行增广，停止算法执行（理由接下来会讲到）。答案就是 $sum + cost$。 建图的原理： 我们先计算出原矩阵与零矩阵的 $S$ 值。接下来跑费用流时，每增加一个流，相当于进行了一次操作，那么与原图的差距就会缩小，而其费用就是每进行一次操作可以减小的 $S$ 值。由于对于每个点其边的费用是单调递增的，所以跑最小费用流可以保证其从小的流起（这也算是一种常见的网络流建模技巧了）。然后显然我们并不需要也不能跑最大流，而是当本次操作的费用变为非负时，意味着已经不能再减小 $S$ 了，也就不再需要增广了。 Ps: 一开始一直卡在费用流跑到什么时候结束，因为知道不是最大流… 已经遇到过不少次这种只跑最小费用不跑最大流的问题了，看来还是要多 review。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;const int MAXN = 1e3 + 10;const int MAXM = 1e5 + 10;const int INF = 0x3f3f3f3f;struct Edge &#123; int to, cap, cost, next; Edge( int to = 0, int cap = 0, int cost = 0, int next = 0 ) : to(to), cap(cap), cost(cost), next(next) &#123;&#125;&#125; G[MAXM];int n, m;int tot, head[MAXN];int d[MAXN], pre[MAXN];int A[MAXN][MAXN];int dx[] = &#123;-1, 0, 0, 1&#125;;int dy[] = &#123;0, 1, -1, 0&#125;;bool ok(int x, int y)&#123; return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; m;&#125;void init()&#123; tot = 0; memset(head, -1, sizeof(head));&#125;void addEdge(int u, int v, int cap, int cost = 0)&#123; G[tot] = Edge(v, cap, cost, head[u]); head[u] = tot++; G[tot] = Edge(u, 0, -cost, head[v]); head[v] = tot++;&#125;bool spfa(int s, int t)&#123; memset(pre, -1, sizeof(pre)); fill(d, d + n * m + 2, INF); queue&lt;int&gt; que; d[s] = 0; que.push(s); while( !que.empty() ) &#123; int u = que.front(); que.pop(); for( int i = head[u]; ~i; i = G[i].next ) &#123; Edge&amp; e = G[i]; if( e.cap &gt; 0 &amp;&amp; d[e.to] &gt; d[u] + e.cost ) &#123; d[e.to] = d[u] + e.cost; pre[e.to] = i; que.push(e.to); &#125; &#125; &#125; return d[t] &lt; 0;&#125;int MinCostMaxFlow(int s, int t)&#123; int cost = 0; while( spfa(s, t) ) &#123; int Min = INF; for( int i = pre[t]; ~i; i = pre[G[i ^ 1].to] ) &#123; Edge&amp; e = G[i]; Min = min(Min, e.cap); &#125; for( int i = pre[t]; ~i; i = pre[G[i ^ 1].to] ) &#123; Edge&amp; e = G[i]; e.cap -= Min; G[i ^ 1].cap += Min; &#125; cost += d[t]; &#125; return cost;&#125;int main()&#123; int T, cas = 0; scanf("%d", &amp;T); while( T-- ) &#123; init(); int k; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); int sum = 0; for( int i = 0; i &lt; n; ++ i ) &#123; for( int j = 0; j &lt; m; ++ j ) &#123; scanf("%d", &amp;A[i][j]); sum += A[i][j] * A[i][j]; &#125; &#125; int s = 0, t = n * m + 1; for( int i = 0; i &lt; n; ++ i ) &#123; for( int j = 0; j &lt; m; ++ j ) &#123; if( (i + j) &amp; 1 ) &#123; for( int l = 1; l &lt;= k; ++ l ) &#123; addEdge(i * m + j + 1, t, 1, 2 * l - 2 * A[i][j] - 1); &#125; &#125; else &#123; for( int l = 1; l &lt;= k; ++ l ) &#123; addEdge(s, i * m + j + 1, 1, 2 * l - 2 * A[i][j] - 1); &#125; for( int l = 0; l &lt; 4; ++ l ) &#123; int x = i + dx[l]; int y = j + dy[l]; if( ok(x, y) ) &#123; addEdge(i * m + j + 1, x * m + y + 1, INF); &#125; &#125; &#125; &#125; &#125; printf("Case %d: %d\n", ++cas, sum + MinCostMaxFlow(s, t)); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Codeforces Round 345（Div. 2）]]></title>
      <url>%2F2016%2F04%2F12%2FCodeforces-Round-345-(Div-2)%2F</url>
      <content type="text"><![CDATA[Codeforces Round #345 (Div. 2) A、B、C、D、E 解题报告一时兴起，准备在暑假前做满39场 CF Div.2，并写题解发布在Blog上。 这是第一场！题目在此。 A. Joysticks题目大意现有两个游戏手柄，初始电量（百分数）分别为 $a_1$，$a_2$。每一分钟你可以选择为其中一个手柄充电 1%（电量可超过100%），同时另一个手柄将会耗电 2%。当有任意一只手柄的电量降低到0，游戏结束。问游戏最长时间。$(1 \leq a_1, a_2 \leq 100)$ 时限 $1s$。 解题思路贪心。每次选择电量较低的手柄进行充电，由于数据较小可直接模拟。Ps：官方题解说还可以直接 $O(1)$ 算公式，然而我转了一圈并没有发现有算公式的…我也不会：) 解题代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 10;int main()&#123; int n, m; while( ~scanf("%d %d", &amp;n, &amp;m) ) &#123; int cnt = 0; while( n &gt; 0 &amp;&amp; m &gt; 0 ) &#123; if( n &gt; m ) swap(n, m); n ++; m -= 2; cnt++; &#125; if( n &lt; 0 || m &lt; 0 ) cnt--; printf("%d\n", cnt); &#125; return 0;&#125; B. Beautiful Paintings题目大意给定一组数列 $a_1, a_2, …, a_n$，要求通过调整位置使得 $a_i &lt; a_{i+1}$ $(1 \leq i \leq n - 1)$ 对数最多。输出最大对数。$(1 \leq n \leq 1000, 1 \leq a_i \leq 1000)$ 时限 $1s$。 解题思路贪心：排序+二分。将数列按从小到大进行排序，然后对于每一个 $a_i$，二分找第一个比它大的数，若找到答案+1，并将找到的数删除（之后依然要进行遍历）。这样的复杂度是 $O(nlogn)$ 的。 $O(n)$的做法是，统计相同权值出现的最大次数，答案就是 $n-most$。算法原理是对于其他权值都可以与出现次数最多的权值组成一对，然后最大对数就是 $n-most$ 啦。 解题代码$O(nlogn)$:123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 10;int a[MAXN];multiset&lt;int&gt; ms;int main()&#123; int n; while( ~scanf("%d", &amp;n) ) &#123; ms.clear(); for( int i = 0; i &lt; n; ++ i ) &#123; scanf("%d", a + i); ms.insert(a[i]); &#125; sort(a, a + n); int cnt = 0; multiset&lt;int&gt;::iterator itk; for( int i = 0; i &lt; n; ++ i ) &#123; itk = ms.upper_bound(a[i]); if( itk == ms.end() ) break; ms.erase(itk); cnt++; &#125; printf("%d\n", cnt); &#125; return 0;&#125; $O(n)$:123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 10;int a[MAXN];int main()&#123; int n; while( ~scanf("%d", &amp;n) ) &#123; int most = 0, x; for( int i = 0; i &lt; n; ++ i ) &#123; scanf("%d", &amp;x); a[x]++; most = max(most, a[x]); &#125; printf("%d\n", n - most); &#125; return 0;&#125; C. Watchmen题目大意在二维平面上，给定 $n$ 个点，问有多少对点对满足点对之间的曼哈顿距离等于欧几里得距离。$(1 \leq n \leq 2*10^5, |x_i|,|y_i| \leq 10^9)$ 时限 $3s$。 解题思路显然满足条件的点对要么 $x$ 坐标相同，要么 $y$ 坐标相同。由此可以统计相同 $x$ 坐标的点数和相同 $y$ 坐标的点数以及重合点的点数。然后直接排列组合+容斥搞搞就可以了。统计：If we use TreeMap/sort then solution will run in $O(nlogn)$ and if unordered_map/HashMap then in $O(n)$. 解题代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;const int MAXN = 1e5 + 10;int n;map&lt;int, int&gt; mp_x, mp_y;map&lt;P, int&gt; mp_xy;int main()&#123; while( ~scanf("%d", &amp;n) ) &#123; int x, y; for( int i = 0; i &lt; n; ++ i ) &#123; scanf("%d %d", &amp;x, &amp;y); mp_x[x]++; mp_y[y]++; mp_xy[P(x, y)]++; &#125; ll ans = 0; for( auto i : mp_x ) &#123; ans += (ll)i.second * (i.second - 1) / 2; &#125; for( auto i : mp_y ) &#123; ans += (ll)i.second * (i.second - 1) / 2; &#125; for( auto i : mp_xy ) &#123; ans -= (ll)i.second * (i.second - 1) / 2; &#125; printf("%I64d\n", ans); &#125; return 0;&#125; D. Image Preview题目大意你在翻阅手机照片，初始在照片 1 的为位置，共 $n$ 张照片，首尾相连。向左向右切换照片需要消耗 $a$ 秒，如果没看过某张照片，消耗 1 秒观看（不能直接跳过没看过的照片），如果照片旋转方向（横或竖）不对，观看前消耗 $b$ 秒旋转。问 $T$ 秒时间内最多能看多少张照片。$(1 \leq n \leq 5 * 10^5, 1 \leq a,b \leq 1000, 1 \leq T \leq 10^9)$ 时限 $1s$。 解题思路显然最优解只有4种情况： 一直向右 一直向左 先向右再向左 先向左再向右由此我们使用两个指针，一开始左指针在初始位置，右指针一直向右扫，当右指针扫到极限时，将左指针一步一步往左移，相当于用类似尺取的方法进行求解。这种算法的复杂度是 $O(n)$ 的，不过细节问题很容易出错。 更简单的方法是枚举左端点 + 二分右端点，比较容易写（看起来？），不过复杂度是 $O(nlogn)$。 解题代码（多揣摩）1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 5e5 + 10;char s[MAXN];int main()&#123; int n, A, B, T; while( ~scanf("%d %d %d %d %s", &amp;n, &amp;A, &amp;B, &amp;T, s) ) &#123; int ans = 0, l = n; while( l &amp;&amp; T &gt; 0 ) &#123; --l; T -= A + 1; if( s[l] == 'w' ) T -= B; &#125; T += A + 1; if( s[l] == 'w' ) T += B; ++l; for( int i = 0; i &lt; n; ++ i ) &#123; if( i ) T -= A + 1; else --T; if( s[i] == 'w' ) T -= B; while( l &lt;= i || l &lt; n &amp;&amp; T - A * min(i, n - l) &lt; 0 ) &#123; T += A + 1; if( s[l] == 'w' ) T += B; l++; &#125; if( T - A * min(i, n - l) &gt;= 0 ) ans = max(ans, n - l + i + 1); &#125; printf("%d\n", ans); &#125; return 0;&#125; E.Table Compression题目大意给定一个 $n * m$ 的表格，要求找到同样大小的表格，并满足： 每行每列中：各格子上的数字大小关系和原表格中的一样。 特别地，每行每列数字相同的格子，在新表格中也必相同。 表格上的最大的数字尽量小。 $(1 \leq n, m$ $and$ $n * m \leq 10^6, 1 \leq a_{i,j} \leq 10^9)$ 时限 $4s$。 解题思路并查集+拓扑排序。将每行每列上的数字分别排序，然后相邻位置（防止不必要的连边）按从小到大进行连边。这样就可以造出一个DAG，直接跑拓扑排序就可以了——每次取出入度为0的点，更新其到出边上点的距离的最大值。或者也可以每次都一次性取出所有入度为0的点，然后进行赋值，不过这样比较麻烦，而且更耗时间。 然后对于题目的第二个条件，一开始我的做法是按上面排完序后，对于每个值二分找到行和列中第一个与其相等的值，然后合并成一个点，再继续二分寻找…然后就是一直 $Wrong$ $answer$ $on$ $test$ $46$…（虽然知道这样写很挫但不明白为什么会错） 后来改成并查集才AC的。也就是排完序后将每行每列相同权值的直接进行合并。注意要先跑完并查集才可以开始连边，原因也是显而易见的。 解题代码AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;const int MAXN = 1e6 + 10;int n, m;int in[MAXN], pa[MAXN], dp[MAXN];map&lt;int, int&gt; mp;set&lt;P&gt; sx[MAXN], sy[MAXN];set&lt;P&gt; st;vector&lt;int&gt; G[MAXN];int findPa(int x)&#123; return pa[x] == x ? x : pa[x] = findPa(pa[x]);&#125;void uniteSet(int u, int v)&#123; u = findPa(u), v = findPa(v); if( u != v ) pa[v] = u;&#125;void addEdge(int u, int v)&#123; G[u].push_back(v); in[v]++;&#125;void Mapping(bool isU, set&lt;P&gt; st)&#123; set&lt;P&gt;::iterator ite, itk; for( ite = st.begin(); ite != st.end(); ++ ite ) &#123; itk = ite++; if( ite == st.end() ) break; if( isU &amp;&amp; (*itk).first == (*ite).first ) uniteSet((*itk).second, (*ite).second); else if( !isU &amp;&amp; (*itk).first != (*ite).first ) addEdge(findPa((*itk).second), findPa((*ite).second)); ite = itk; &#125;&#125;void topoSort()&#123; queue&lt;int&gt; que; int sum = (n - 1) * m + m; fill(dp, dp + sum, 1); for( int i = 0; i &lt; sum; ++ i ) &#123; if( !in[i] ) que.push(i); &#125; while( !que.empty() ) &#123; int u = que.front(); que.pop(); for( int i = 0; i &lt; G[u].size(); ++ i ) &#123; int v = G[u][i]; if( !(--in[v]) ) que.push(v); dp[v] = max(dp[v], dp[u] + 1); &#125; &#125;&#125;int main()&#123; while( ~scanf("%d %d", &amp;n, &amp;m) ) &#123; int x, sum = (n - 1) * m + m; for( int i = 0; i &lt; sum; ++ i ) pa[i] = i; for( int i = 0; i &lt; n; ++ i ) &#123; for( int j = 0; j &lt; m; ++ j ) &#123; scanf("%d", &amp;x); mp[i * m + j] = x; sx[i].insert(P(x, i * m + j)); &#125; Mapping(1, sx[i]); &#125; for( int j = 0; j &lt; m; ++ j ) &#123; for( int i = 0; i &lt; n; ++ i ) &#123; int u = i * m + j; sy[j].insert(P(mp[u], u)); &#125; Mapping(1, sy[j]); &#125; for( int i = 0; i &lt; n; ++ i ) &#123; Mapping(0, sx[i]); &#125; for( int j = 0; j &lt; m; ++ j ) &#123; Mapping(0, sy[j]); &#125; topoSort(); for( int i = 0; i &lt; n; ++ i ) &#123; for( int j = 0; j &lt; m; ++ j ) &#123; printf("%d%c", dp[findPa(i * m + j)], " \n"[j == m - 1]); &#125; &#125; &#125; return 0;&#125; 错误代码（求帮找错QAQ)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// Wrong answer on test 46#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;const int MAXN = 1e6 + 10;int n, m, num;int in[MAXN], va[MAXN];vector&lt;int&gt; G[MAXN];map&lt;P, int&gt; mp;map&lt;P, int&gt; mpv;//set&lt;P&gt; st;set&lt;P&gt; sx[MAXN];set&lt;P&gt; sy[MAXN];void topoSort()&#123; queue&lt;int&gt; que; fill(va + 1, va + num, 1); for( int i = 1; i &lt; num; ++ i ) &#123; if( !in[i] ) que.push(i); &#125; while( !que.empty() ) &#123; int u = que.front(); que.pop(); for( int j = 0; j &lt; G[u].size(); ++ j ) &#123; int v = G[u][j]; --in[v]; if( !in[v] ) que.push(v); va[v] = max(va[v], va[u] + 1); &#125; &#125;&#125;void add_edge(int u, int v)&#123; G[u].push_back(v); in[v]++;&#125;queue&lt;P&gt; pque;// Wrong answer on test 46void bfs(int x, int y, int fx)&#123; pque.push(P(x, y)); mpv[P(x, y)] = num; while( !pque.empty() ) &#123; P p = pque.front(); pque.pop(); int u = p.first, v = p.second; set&lt;P&gt;::iterator ite; ite = sx[u].upper_bound(P(fx, v)); if( ite != sx[u].end() &amp;&amp; (*ite).first == fx &amp;&amp; !mpv[P(u, (*ite).second)] ) &#123; mpv[P(u, (*ite).second)] = num; pque.push(P(u, (*ite).second)); &#125; ite = sy[v].upper_bound(P(fx, u)); if( ite != sy[v].end() &amp;&amp; (*ite).first == fx &amp;&amp; !mpv[P((*ite).second, v)] ) &#123; mpv[P((*ite).second, v)] = num; pque.push(P((*ite).second, v)); &#125; &#125; num++;&#125;int main()&#123; while( ~scanf("%d %d", &amp;n, &amp;m) ) &#123; num = 1; int x; for( int i = 0; i &lt; n; ++ i ) &#123; for( int j = 0; j &lt; m; ++ j ) &#123; scanf("%d", &amp;x); mp[P(i, j)] = x; sx[i].insert(P(x, j)); &#125; &#125; for( int j = 0; j &lt; m; ++ j ) &#123; for( int i = 0; i &lt; n; ++ i ) &#123; sy[j].insert(P(mp[P(i, j)], i)); &#125; &#125; for( int i = 0; i &lt; n; ++ i ) &#123; for( int j = 0; j &lt; m; ++ j ) &#123; if( !mpv[P(i, j)] ) &#123; bfs(i, j, mp[P(i, j)]); &#125; &#125; &#125; for( int i = 0; i &lt; n; ++ i ) &#123; set&lt;P&gt;::iterator ite, itk; for( ite = sx[i].begin(); ite != sx[i].end(); ++ ite ) &#123; itk = ite++; if( ite == sx[i].end() ) break; int u = (*itk).second, v = (*ite).second; int l = mpv[P(i, u)], r = mpv[P(i, v)]; if( l != r ) add_edge(l, r); ite = itk; &#125; &#125; for( int i = 0; i &lt; n; ++ i ) sx[i].clear(); for( int j = 0; j &lt; m; ++ j ) &#123; set&lt;P&gt;::iterator ite, itk; for( ite = sy[j].begin(); ite != sy[j].end(); ++ ite ) &#123; itk = ite++; if( ite == sy[j].end() ) break; int u = (*itk).second, v = (*ite).second; int l = mpv[P(u, j)], r = mpv[P(v, j)]; if( l != r ) add_edge(l, r); ite = itk; &#125; &#125; for( int j = 0; j &lt; m; ++ j ) sy[j].clear(); topoSort(); for( int i = 0; i &lt; n; ++ i ) &#123; for( int j = 0; j &lt; m; ++ j ) &#123; printf("%d%c", va[mpv[P(i, j)]], " \n"[j == m - 1]); &#125; &#125; &#125; return 0;&#125; 附上一份官方题解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZOJ 3643 Keep Deleting（KMP + 栈）]]></title>
      <url>%2F2016%2F03%2F26%2Fzoj-3643%2F</url>
      <content type="text"><![CDATA[题目大意给定长度为 $N$ 的字符串 $A$ 和长度为 $M$ 的字符串 $B$。每次从左往右看，如果发现 $A$ 作为 $B$ 的 $substring$ 出现，那么在 $B$ 中删除 $A$。对新的字符串递归进行此操作。求最大删除次数。$( N \leq 256, M \leq 512000)$ 解题思路KMP + 栈。 首先对字符串 $A$ 进行 $KMP$ 的预处理操作，得到 $Next[i]$ 。 然后从左往右遍历字符串 $B$，按照 $KMP$ 算法进行匹配操作，并用一个栈维护 “$B$ 中已经扫描过但仍未被删除的字符与模式串 $A$ 中对应字符的匹配位置”，如此，每当 $KMP$ 成功匹配一次，答案加 $1$，把栈顶的 $A.length()$ 个元素出栈，并让模式串 $A$ 的匹配位置回退到现在栈顶元素所保存的位置。一直遍历到 $B$ 结束。 Note: 似乎不用KMP，单纯使用strcmp()函数 + 栈也可以过。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;const int MAXN = 256 + 10;const int MAXM = 512000 + 10;char A[MAXN], B[MAXM];int Next[MAXN], Stack[MAXM];void getNext()&#123; int i = 0, j = Next[0] = -1, len = strlen(A); while( i &lt; len ) &#123; while( ~j &amp;&amp; A[i] != A[j] ) j = Next[j]; if( A[++i] == A[++j] ) Next[i] = Next[j]; else Next[i] = j; &#125;&#125;int main()&#123; while( ~scanf("%s %s", A, B) ) &#123; getNext(); int Alen = strlen(A), Blen = strlen(B); int top = 0, j = 0, ans = 0; for( int i = 0; i &lt; Blen; ++ i ) &#123; while( ~j &amp;&amp; B[i] != A[j] ) j = Next[j]; Stack[top++] = ++j; if( j == Alen ) &#123; ans++; top -= Alen; j = Stack[top - 1]; &#125; &#125; printf("%d\n", ans); &#125; return 0;&#125; Ps: KMP老是忘…这可不太妙，每次都要重新理解太浪费时间了…还是要多 review。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二分搜索法简单分析与总结]]></title>
      <url>%2F2016%2F03%2F18%2F%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%B3%95%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[二分搜索法，是通过不断缩小解可能存在的范围，从而求得问题最优解的方法。在程序设计竞赛特别是ACM中，经常可以见到二分搜索法和其他算法结合的题目。 本文主要总结了二分的几种常用写法。 lower_bound给定长度为 $n$ 的单调不下降数列 $a_0,a_1,…,a_{n-1}$ 和一个数 $k$，求满足 $a_i \geq k$ 条件的最小的 $i$。不存在的情况下输出 $n$。 满足“二分值越大越容易满足条件”，等同于“最小化最大值”，参见下方描述。 upper_bound给定长度为 $n$ 的单调不下降数列 $a_0,a_1,…,a_{n-1}$ 和一个数 $k$，求满足 $a_i &gt; k$ 条件的最小的 $i$。不存在的情况下输出 $n$。 满足“二分值越大越容易满足条件”，等同于“最小化最大值”，参见下方描述。 最大化最小值此种题目一般是“二分值越小越容易满足条件”，然后求符合条件的最大值。 区间长度为1时的写法：解的范围为 $[lb, rb]$。123456789// 计算区间为[lb, rb]while( rb &gt; lb ) // 区间长度为1时终止循环&#123; // 防止溢出 int m = lb + (rb - lb + 1) / 2; // 由于是区间长度为1时终止循环，所以要加1 if( ok(m) ) lb = m; else rb = m - 1;&#125;// 跳出循环时 lb == rb 区间长度为2时的写法：解的范围为 $[lb, rb)$。123456789while( rb - lb &gt; 1 ) // 区间长度为2时终止循环&#123; // 防止溢出 int m = lb + (rb - lb) / 2; // 由于是区间长度为2时终止循环，所以不用加1（不会死循环） if( ok(m) ) lb = m; else rb = m;&#125;// 跳出循环时 lb + 1 == rb// 答案为 lb 最小化最大值此种题目一般是“二分值越大越容易满足条件”，然后求符合条件的最小值。 区间长度为1时的写法：解的范围为 $[lb, rb]$。12345678while( rb &gt; lb )&#123; // 防止溢出 int m = lb + (rb - lb) / 2; // 这里虽然区间长度为1，但不需要加1（不会死循环） if( ok(m) ) rb = m; else lb = m + 1;&#125;// 跳出循环时 lb == rb 区间长度为2时的写法：解的范围为 $(lb, rb]$。123456789while( rb - lb &gt; 1 )&#123; // 防止溢出 int m = lb + (rb - lb) / 2; if( ok(m) ) rb = m; else lb = m;&#125;// 跳出循环时 lb + 1 == rb// 答案为 rb 浮点数的二分浮点数二分一般直接指定循环次数（100次）作为终止条件。1次循环可以把区间的范围缩小一半，100次的循环则可以达到 $2^{-100} \approx 10^{-30}$ 的精度范围，基本上是没有问题的。123456for( int i = 0; i &lt; 100; ++ i )&#123; double m = (lb + rb) / 2; ...&#125;// 跳出循环时 lb 与 rb 近似相等，所以都可作为答案 此外，也可以类比整数的二分，把终止条件设为像 $(r - l)/2 &gt; EPS$，依然通过指定一个区间的大小来终止循环。但是，如果 $EPS$ 取得太小了，就有可能因为浮点小数精度的原因导致陷入死循环。因此，对于浮点数，一般还是建议通过指定循环次数来作为终止条件。 总结其实重点还是 最大化最小值 和 最小化最大值 的区分。可以发现： 对于区间长度为1的写法，两者的解存在范围都是闭区间。即初始化时 $lb$ 作为解的最小值，$rb$ 作为解的最大值就可以了。唯一不同的是，求 最大化最小值 时，中间值的计算需要加1再除以2。这是这种写法的一个特征，可以自己手动验算下区间长度为1时是否能跳出循环。 对于区间长度为2的写法，两者的解存在范围都是半开半闭区间。即初始化时，有一边（左/右）需要加1或减1（以保证能求到解的最值）。答案也不同，一个是左值，一个是右值。 写法记一种就够了，记多了反而容易混淆。当然，归根结底，还是要多做题，多思考…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5639 Deletion（网络流）]]></title>
      <url>%2F2016%2F03%2F17%2Fhdu-5639%2F</url>
      <content type="text"><![CDATA[题目大意给出一个 $n$ 个点 $m$ 条边的无向图 $G$，每次你可以选择一些边，从图中删掉。要求选出来的边构成的子图的每个连通块最多只有一个环。 问最少需要删几次才能把所有边都删掉。 $(1 \leq n \leq 2000, 0 \leq m \leq 2000)$ 解题思路网络流。 官方题解： 方法一:考虑删掉的边的形态，就是我们经常见到的环套树这种结构，参考平时这种图给出的方法，如果一个图的每个点的出边只有一条，那么一定会构成环套树这种结构。于是问题可以转化成，给无向图的每条边定向，使得出度最大点的出度最小 (每个点的出度大小对应了删的次数)。 显然，这个东西使可以二分的，不妨设二分值为 $x$。考虑混合图的欧拉回路的做法，利用网络流判合法。先给每条无向边随便定向，对于出度大于 $x$ 的，从源点连一条流量为 $deg-x$ 的边，对于出度小于 $x$ 的，从这个点连一条流量为 $x-deg$ 的边到汇点。对于原来图中的边，流量为 $1$ 加到网络流图中。只要满流就是合法。 方法二:类似方法一，要求的无非是每条边的归属问题，对于每条边 $(a,b)$，它可以属于 $a$ 或者 $b$，那么新建一个节点表示这条边，并和 $a$，$b$ 都相邻，这样就得到了一个二分图。左边是原图中的节点，右边是原图中的边。二分每个左边每个节点的容量 $k$，如果右边的点能够完全匹配，那么这个 $k$ 就是可行的，找到最小的 $k$ 即可。转化成二分图多重匹配问题。 方法三:事实上这题存在 $O(nm)$ 的做法，只要在方法二的基础上继续改进就好了，二分是没有必要的。注意到每次增广的时候，增光路中只有端点的容量会变化，增广路中间的点的容量都不会变化。那么之要每次增广到端点容量最小的那个点就好了。 感觉题目很不错，所以虽然代码是照着题解写的，但还是放上来了。特别是借鉴混合图的欧拉回路思想这点很妙。 另：方法三还不是很理解，有机会再看看。 代码如下：（采用方法二） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; P;const int MAXN = 2e3 + 10;const int MAXM = 1e5 + 10;const int INF = 0x3f3f3f3f;struct edge &#123; int to, cap, next; edge( int to = 0, int cap = 0, int next = 0 ) : to(to), cap(cap), next(next) &#123;&#125;&#125; G[MAXM];vector&lt;P&gt; E;int n, m;int tot, head[MAXN &lt;&lt; 1], cur[MAXN &lt;&lt; 1];int d[MAXN &lt;&lt; 1];bool bfs(int s, int t)&#123; memset(d, -1, sizeof(d)); queue&lt;int&gt; que; que.push(s); d[s] = 0; while( !que.empty() ) &#123; int u = que.front(); que.pop(); for( int i = head[u]; ~i; i = G[i].next ) &#123; edge &amp;e = G[i]; if( e.cap &gt; 0 &amp;&amp; d[e.to] == -1 ) &#123; d[e.to] = d[u] + 1; que.push(e.to); &#125; &#125; &#125; return ~d[t];&#125;int dfs(int u, int t, int f)&#123; if( u == t ) return f; int res = 0; for( int &amp;i = cur[u]; ~i; i = G[i].next ) &#123; edge &amp;e = G[i]; if( e.cap &gt; 0 &amp;&amp; d[e.to] == d[u] + 1 ) &#123; int temp = dfs(e.to, t, min(e.cap, f)); if( temp &gt; 0 ) &#123; res += temp; f -= temp; G[i].cap -= temp; G[i ^ 1].cap += temp; if( !f ) break; &#125; &#125; &#125; return res;&#125;int Dinic(int s, int t)&#123; int f = 0; while( bfs(s, t) ) &#123; memcpy(cur, head, sizeof(head)); f += dfs(s, t, INF); &#125; return f;&#125;void add_edge(int u, int v, int cap)&#123; G[tot] = edge(v, cap, head[u]); head[u] = tot++; G[tot] = edge(u, 0, head[v]); head[v] = tot++;&#125;void init()&#123; tot = 0; memset(head, -1, sizeof(head));&#125;int main()&#123; int T; scanf("%d", &amp;T); while( T-- ) &#123; E.clear(); init(); scanf("%d %d", &amp;n, &amp;m); if( !m ) &#123; puts("0"); continue; &#125; int s = 0, t = n + m + 1; int u, v; for( int i = 0; i &lt; m; ++ i ) &#123; scanf("%d %d", &amp;u, &amp;v); E.push_back(make_pair(u, v)); &#125; int l = 1, r = m; while( r - l &gt;= 0 ) &#123; int mm = (l + r) &gt;&gt; 1; init(); for( int i = 1; i &lt;= n; ++ i ) add_edge(s, i, mm); for( int i = 0; i &lt; m; ++ i ) &#123; P p = E[i]; add_edge(p.first, n + i + 1, 1); add_edge(p.second, n + i + 1, 1); add_edge(n + i + 1, t, 1); &#125; int flow = Dinic(s, t); if( flow == m ) r = mm - 1; else l = mm + 1; &#125; printf("%d\n", l); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[POJ 1637 Sightseeing tour（混合图的欧拉回路：网络流）]]></title>
      <url>%2F2016%2F03%2F17%2Fpoj-1637%2F</url>
      <content type="text"><![CDATA[题目大意给定一副 $n$ 个点， $m$ 条边的混合图（既有有向边，又有无向边），问是否存在欧拉回路。$( 1 \leq n \leq 200, 1 \leq m \leq 1000)$ 知识扩展若图G中存在这样一条路径，使得它恰通过G中每条边一次,则称该路径为欧拉路径。若该路径是一个圈，则称为欧拉回路。 具有欧拉回路的图称为欧拉图（简称E图）。 无向图存在欧拉路径/回路的充要条件：一个无向连通图图存在欧拉路径，当且仅当有且仅有2个度数为奇数的点。特别地，当所有点的度数都为偶数时，则称为欧拉回路。 有向图存在欧拉路径/回路的充要条件：一个有向连通图存在欧拉路径，当且仅当除了2个点外，其余的点入度等于出度，且在这2个点中，一个点的入度比出度大1，另一个点的出度比入度大1。特别地，当所有点的入度等于出度时，则称为欧拉回路。 解题思路网络流。 要判断一个混合图是否存在欧拉路径，首先得把混合图转化为有向图，也即给无向边定向。 先随便定向，再判断其是否满足有向图存在欧拉回路的先决条件，也即是否所有点的入度等于出度。由于是随便定向，直接这样判断肯定是错误的，但可以发现，无论怎么定向，一个点的总度数是不会变的，而由入度等于出度可以推出每个点的度数（入度+出度）必是偶数。所以我们通过这个可以先排除掉一些不可能的图。 Ps: 有些人是通过 入度-出度=偶数 来判断的，也是可以的，道理相通。 然后就可以通过网络流建模来帮助我们找出一种正确的定向方案。 设一个点的权值为（入度-出度）/2，也即该点需要改变方向的边数。我们把图转为二分图，$X$ 集合是出度大于入度的点，$Y$ 集合是入度大于出度的点。然后从源点 $s$ 向 $X$ 集合中的点建边（容量为点权），从 $Y$ 集合中的点向汇点 $t$ 建边（容量为点权）。 至于出度等于入度的点，由于不需要调整，可以选择不加入图（若加入也相当于“中间点”，不会有影响）。 之后再把之前暂时定向的无向边加到图中去（以有向边的形式，在 $X$ 集合与 $Y$ 集合之间），且容量为1。原来的有向边由于无法改变方向，所以直接删除。 最后直接跑最大流判断是否满流就可以了。 Ps: 若有要求输出路径，可将 $X$ 集合与 $Y$ 集合之间流量为1的边反向输出。 网络流建模的原理： $X$ 集合中的点每流出一个流量单位，意味着这条边可以通过在原图中反向定向来使得该点的入出度更趋于相等（一个增加1度，一个减少1度，差值缩小了2度，这也是建图时点权需要除以2的原因）。 多揣摩揣摩就可以理解了。只能说真的很妙。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;const int MAXN = 2e2 + 10;const int MAXM = 1e3 + 10;const int INF = 0x3f3f3f3f;struct edge &#123; int to, cap, next; edge( int to = 0, int cap = 0, int next = 0 ) : to(to), cap(cap), next(next) &#123;&#125;&#125; G[MAXM &lt;&lt; 2];int n, m;int tot, head[MAXN], cur[MAXN];int ou[MAXN], in[MAXN];bool maze[MAXN][MAXN];int d[MAXN];bool bfs(int s, int t)&#123; memset(d, -1, sizeof(d)); queue&lt;int&gt; que; que.push(s); d[s] = 0; while( !que.empty() ) &#123; int u = que.front(); que.pop(); for( int i = head[u]; ~i; i = G[i].next ) &#123; edge e = G[i]; if( e.cap &gt; 0 &amp;&amp; d[e.to] == -1 ) &#123; d[e.to] = d[u] + 1; que.push(e.to); &#125; &#125; &#125; return ~d[t];&#125;int dfs(int u, int t, int f)&#123; if( u == t ) return f; int res = 0; for( int &amp;i = cur[u]; ~i; i = G[i].next ) &#123; edge &amp;e = G[i]; if( e.cap &gt; 0 &amp;&amp; d[e.to] == d[u] + 1 ) &#123; int tmp = dfs(e.to, t, min(e.cap, f)); if( tmp &gt; 0 ) &#123; res += tmp; f -= tmp; e.cap -= tmp; G[i ^ 1].cap += tmp; if( !f ) break; &#125; &#125; &#125; return res;&#125;int Dinic(int s, int t)&#123; int flow = 0; while( bfs(s, t) ) &#123; memcpy(cur, head, sizeof(head)); int tmp; while( tmp = dfs(s, t, INF) ) flow += tmp; &#125; return flow;&#125;void add_edge(int u, int v, int cap)&#123; G[tot] = edge(v, cap, head[u]); head[u] = tot++; G[tot] = edge(u, 0, head[v]); head[v] = tot++;&#125;void init()&#123; tot = 0; memset(head, -1, sizeof(head)); memset(ou, 0, sizeof(ou)); memset(in, 0, sizeof(in)); memset(maze, 0, sizeof(maze));&#125;int main()&#123; int T; scanf("%d", &amp;T); while( T-- ) &#123; init(); scanf("%d %d", &amp;n, &amp;m); int u, v, o; for( int i = 0; i &lt; m; ++ i ) &#123; scanf("%d %d %d", &amp;u, &amp;v, &amp;o); ou[u]++; in[v]++; if( !o ) &#123; add_edge(u, v, 1); maze[u][v] = true; &#125; &#125; int sum = 0, s = 0, t = n + 1; bool flag = true; for( int i = 1; i &lt;= n; ++ i ) &#123; if( (ou[i] + in[i]) &amp; 1 ) flag = false; if( ou[i] &gt; in[i] ) sum += (ou[i] - in[i]) &gt;&gt; 1; &#125; if( flag ) &#123; for( int i = 1; i &lt;= n; ++ i ) &#123; if( ou[i] &gt; in[i] ) add_edge(s, i, (ou[i] - in[i]) &gt;&gt; 1); else if( ou[i] &lt; in[i] ) add_edge(i, t, (in[i] - ou[i]) &gt;&gt; 1); &#125; int flow = Dinic(s, t); if( sum != flow ) flag = false; &#125; if( flag ) puts("possible"); else puts("impossible"); &#125; return 0;&#125; 个人体会重要的不是记住混合图的欧拉路径怎么求，而是要理解网络流在这里的妙用，才能真正触类旁通，举一反三。 Brain Power若题目要求判断的是 是否存在欧拉路径 。那又该怎么做呢？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[URAL 2030 Awesome Backup System（BFS序 + 树状数组）]]></title>
      <url>%2F2016%2F03%2F16%2Fural-2030%2F</url>
      <content type="text"><![CDATA[题目大意给定一棵有 $n$ 个结点的树，询问 $m$ 次，操作分为两种： 1 v 使结点 $v$ 的所有邻接顶点的权值增加 $a_i$ 2 v 查询结点 $v$ 的权值 $(1 \leq n \leq 10^5, 0 \leq a \leq 10^9,1 \leq m \leq 10^5)$ 解题思路BFS序 + 树状数组。 利用BFS序对树的结点编号，对于每个结点 $v$，记录其父亲结点 $pa[v]$ 和 儿子结点的区间。然后用树状数组/线段树实现区间更新、单点查询就可以了。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 10;const int MAXM = 1e5 + 10;const int MOD = 1e9 + 7;struct edge &#123; int to, next; edge( int to = 0, int next = 0 ) : to(to), next(next) &#123;&#125;&#125; G[MAXM &lt;&lt; 1];int n;ll a[MAXN];int tot, head[MAXN];int id[MAXN], par[MAXN], son[MAXN][2];ll bit[MAXN];ll sum(int i)&#123; ll s = 0; while( i &gt; 0 ) &#123; s = (s + bit[i] + MOD) % MOD; i -= i &amp; -i; &#125; return s;&#125;void add(int i, ll x)&#123; while( i &lt;= n ) &#123; bit[i] = (bit[i] + x + MOD) % MOD; i += i &amp; -i; &#125;&#125;void bfs(int s)&#123; int clk = 0; queue&lt;int&gt; que; que.push(s); par[s] = 0; id[s] = ++clk; while( !que.empty() ) &#123; int u = que.front(); que.pop(); son[u][0] = clk; for( int i = head[u]; ~i; i = G[i].next ) &#123; int v = G[i].to; if( v == par[u] ) continue; que.push(v); par[v] = u; id[v] = ++clk; &#125; son[u][1] = clk; &#125;&#125;void add_edge(int u, int v)&#123; G[tot] = edge(v, head[u]); head[u] = tot++; G[tot] = edge(u, head[v]); head[v] = tot++;&#125;void init()&#123; tot = 0; memset(head, -1, sizeof(head));&#125;int main()&#123; while( ~scanf("%d", &amp;n) ) &#123; init(); for( int i = 1; i &lt;= n; ++ i ) scanf("%I64d", a + i); int u, v; for( int i = 0; i &lt; n - 1; ++ i ) &#123; scanf("%d %d", &amp;u, &amp;v); add_edge(u, v); &#125; bfs(1); memset(bit, 0, sizeof(bit)); for( int i = 1; i &lt;= n; ++ i ) &#123; add(id[i], a[i]); add(id[i] + 1, -a[i]); &#125; int m; scanf("%d", &amp;m); for( int i = 0; i &lt; m; ++ i ) &#123; scanf("%d %d", &amp;u, &amp;v); ll x = sum(id[v]); if( u == 1 ) &#123; if( par[v] ) &#123; add(id[par[v]], x); add(id[par[v]] + 1, -x); &#125; if( son[v][0] != son[v][1] ) &#123; add(son[v][0] + 1, x); add(son[v][1] + 1, -x); &#125; &#125; else &#123; printf("%I64d\n", x); &#125; &#125; &#125; return 0;&#125; 另一种做法待更新…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树状数组：从单点更新区间查询到区间更新单点查询]]></title>
      <url>%2F2016%2F03%2F16%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%9A%E4%BB%8E%E5%8D%95%E7%82%B9%E6%9B%B4%E6%96%B0%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E5%88%B0%E5%8C%BA%E9%97%B4%E6%9B%B4%E6%96%B0%E5%8D%95%E7%82%B9%E6%9F%A5%E8%AF%A2%2F</url>
      <content type="text"><![CDATA[树状数组（Binary Indexed Tree， BIT）是一种可以实现单点更新，区间查询的数据结构，每次操作复杂度为 $O(logn)$。 它的实现主要包括两个函数: $sum(i)$ 表示 $i$ 所在位置的前缀和（即 $a_1+a_2+…+a_i$，下标从 $1$ 开始） $add(i, x)$ 表示给 $a_i$ 加上 $x$ 这里不详细讲实现的原理，有需要的请自行百度或Google。 BIT的求和 计算前 $i$ 项的和需要从 $i$ 开始，不断把当前位置 $i$ 的值加到结果中，并从 $i$ 中减去 $i$ 的二进制最低非 $0$ 位对应的幂，直到 $i$ 变成 $0$ 为止。 $i$ 的二进制的最后一个 $1$ 可以通过 $i$ &amp; $-i$得到。 12345678910int sum(int i)&#123; int s = 0; while( i &gt; 0 ) &#123; s += bit[i]; i -= i &amp; -i; &#125; return s;&#125; BIT的值的更新 使第 $i$ 项的值增加 $x$ 需要从 $i$ 开始，不断把当前位置 $i$ 的值增加 $x$，并把 $i$ 的二进制最低非 $0$ 位对应的幂加到 $i$ 上。 12345678void add(int i, int x)&#123; while( i &lt;= n ) &#123; bit[i] += x; i += i &amp; -i; &#125;&#125; 转化：从单点更新区间查询转化为区间更新单点查询Ps: 一般来讲，区间总是包含单点的，也就是可以 区间更新/查询 一定也可以 单点更新/查询，反过来却未必。 上面讲的可以实现单点更新区间查询，那如果我们需要区间更新单点查询呢？只能写线段树？ 不是的。我们可以这样进行区间 $[L,R]$ 的更新： add(L, x); add(R + 1, -x); add函数不需要改变。为什么这样就可以呢？考虑 $sum(i)$ 为位置 $i$ 的前缀和，若我们将其当成 $a_i$ 位置的值，那之前的更新就是成功的。比如说一开始要使 $[1,5]$ 的值增加3，按我们的做法，便只有两步操作 $add(1,2)$ 和 $add(5,-2)$。这样当你查询 $a_3$ 的值时，$sum(3)$ 就会计算到之前位置 $1$ 增加的 $2$。就相当于 $3$ 这个位置增加了 $2$。 可能有些人会疑惑 $sum(i)$ 的前缀和部分呢？很简单，我们只要在初始化赋值时这样操作就可以了： add(i, x); add(i + 1, -x); 单点更新同理。 至于说区间更新区间查询，虽然BIT也可以做，但感觉还不如直接线段树来得方便。这里就不细讲了，有兴趣的可以看下《挑战程序设计竞赛》这本书，里面有讲解这种做法。 BIT区间更新单点查询举个栗子：URAL 2030 以上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[URAL 2034 Caravans（最短路 + 二分）]]></title>
      <url>%2F2016%2F03%2F16%2Fural-2034%2F</url>
      <content type="text"><![CDATA[题目大意给出 $n$ 个点，$m$ 条边的无向带权图（权值都为1），镖车将从起点 $s$ 出发到达终点 $f$，保证走最短路径。强盗在点 $r$ 处，他想通过预先埋伏的方式拦截镖车（甚至可以在 $s$ 或者 $f$ 埋伏）。并且强盗希望在离 $r$ 最近的点埋伏，问最坏情况下需要走的最远距离。$( 3 \leq n \leq 10^5, 2 \leq m \leq 10^5)$ 解题思路最短路 + 二分。 题意有点难理解，特别是这部分： Among all such settlements the robbers will choose the one closest to settlement r.They don’t know the caravan’s route yet, but they want to know the maximum distance they will have to go in the worst case to the settlement where they will rob the caravan. 一开始理解为必须保证拦截，所以思路就是求 $s$ 到 $f$ 最短路径图的割点中离 $r$ 距离最短的点。可是又无法解释 “maximum distance”。后来才发现应该是求 $r$ 到最短路（可能不止一条）最近距离的最大值。 最大化最小值。很容易联想到二分。先跑出 $r$ 到各个点的最短距离 $d_i$，然后直接二分答案（距离），每次将小于距离的 $d_i$ 对应的点删除，然后跑 $s$ 到 $f$ 的最短路，看是否满足到 $f$ 的距离最短就可以了。 代码如下：（注意二分的写法：距离越小越满足，越大越不满足，求最大） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;const int MAXN = 1e5 + 10;const int MAXM = 1e5 + 10;struct edge &#123; int to, next; edge( int to = 0, int next = 0 ) : to(to), next(next) &#123;&#125;&#125; G[MAXM &lt;&lt; 1];int n, m;int tot, head[MAXN];int d[MAXN], vis[MAXN], D[MAXN];int s, f, r;int ans;void add_edge(int u, int v)&#123; G[tot] = edge(v, head[u]); head[u] = tot++; G[tot] = edge(u, head[v]); head[v] = tot++;&#125;void init()&#123; tot = 0; memset(head, -1, sizeof(head)); memset(vis, 0, sizeof(vis));&#125;void bfs(int ss)&#123; memset(d, -1, sizeof(d)); if( vis[s] ) return ; queue&lt;int&gt; que; que.push(ss); d[ss] = 0; vis[ss] = true; while( !que.empty() ) &#123; int u = que.front(); que.pop(); for( int i = head[u]; ~i; i = G[i].next ) &#123; int v = G[i].to; if( !vis[v] &amp;&amp; d[v] == -1 ) &#123; d[v] = d[u] + 1; vis[v] = true; que.push(v); &#125; &#125; &#125;&#125;int main()&#123; while( ~scanf("%d %d", &amp;n, &amp;m) ) &#123; init(); int u, v; for( int i = 0; i &lt; m; ++ i ) &#123; scanf("%d %d", &amp;u, &amp;v); add_edge(u, v); &#125; scanf("%d %d %d", &amp;s, &amp;f, &amp;r); bfs(s); ans = d[f]; memset(vis, 0, sizeof(vis)); bfs(r); for( int i = 1; i &lt;= n; ++ i ) D[i] = d[i]; int L = -1, R = 0; for( int i = 1; i &lt;= n; ++ i ) &#123; R = max(R, D[i]); &#125; while( R - L &gt; 1 ) &#123; int m = (L + R) &gt;&gt; 1; memset(vis, 0, sizeof(vis)); for( int i = 1; i &lt;= n; ++ i ) &#123; if( D[i] &lt;= m ) vis[i] = true; &#125; bfs(s); if( d[f] == -1 || d[f] &gt; ans ) R = m; else L = m; &#125; printf("%d\n", R); &#125; return 0;&#125; 另一种方法从起点 $s$ 点出发，顺着到 $f$ 点的最短路径图，更新各路径到 $r$ 的最短距离，和各点所属路径中当前与 $r$ 的最大距离，一直跑到终点 $f$处。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5644 King's Pilots（网络流）]]></title>
      <url>%2F2016%2F03%2F15%2Fhdu-5644%2F</url>
      <content type="text"><![CDATA[题目大意国王阅兵式会持续 $n$ 天，每天都有一场飞机表演，第 $i$ 天的飞行表演需要个 $p_i$ 飞行员。飞行员只愿意无偿工作一天。于是这个国家出台了 $m$ 个休假政策，当某个飞行员工作后，如果支付他 $S_j$ 的酬劳，他会在上次工作 $T_j$ 天后重新回来工作。 开始有 $k$ 名飞行员，当然还可以招募新的飞行员，但是，招募需要 $P$ 天的时间，并且招募来的每个飞行员需要支付 $Q$ 作为酬劳。(也就意味着到第 $P$ 天你才可能用到新招募来的飞行员) 现要求通过合理安排，保证每天的飞行员数量足够（若不能，输出“No solution”），并且让总费用最低。输出总费用。$(m \leq 5, 其他所有数据均在区间[0, 200]内)$ 解题思路最小费用最大流。 此题难就难在建图。 假设先不考虑休假政策： 从源点 $s$ 向每个飞行员连一条容量为 $1$，费用为 $0$ 的边 从每个飞行员向每一天连一条容量为 $1$，费用为 $0$ 的边 从每一天向汇点 $t$ 连一条容量为 $p_i$，费用为 $0$ 的边 上面的建图过程中可以发现，每个飞行员都是相同的，所以可以直接把所有飞行员缩为一个点，甚至直接省略掉。这里可以有两种建图方式： 由源点 $s$ 直接向第一天连一条容量为 $k$，费用为 $0$ 的边，从第 $i$ 天向第 $i+1$ 天连一条容量为 $INF$，费用为 $0$ 的边。 所有飞行员缩成一个点，源点 $s$ 向该点连一条容量为 $k$，费用为 $0$ 的边，该点向每一天连一条容量为 $k$，费用为 $0$ 的边。 本题采用第一种。 招募新的飞行员： 从源点 $s$ 向第 $P$ 天连一条容量为 $INF$，费用为 $0$ 的边（假设采用第一种建图方式） 考虑休假政策： 一开始考虑时是从 $k$ 名飞行员入手，想着如何让其“增加休假属性”。可是一方面又要让其每名飞行员一开始只选择一个点（无偿），一方面又要让其之后能够选择其他点（有偿），两方面难以同时存在。陷入了误区。 其实可以这样考虑，相当于我们有 $k$ 名飞行员是无偿的，其他都是有偿的。也就是把每一天工作过的飞行员当成新的飞行员向之后进行跳转。此时需要把每一天拆成两个点 $x$， $y$： 从 $x_i$ 向 $y_{i+T}$ 连一条容量为 $INF$，费用为 $S$ 的边 从源点 $s$ 向 $x_i$ 连一条容量为 $p_i$，费用为 $0$ 的边 从 $y_i$ 向汇点 $t$ 连一条容量为 $p_i$，费用为 $0$ 的边 可能有些人会疑惑若这一天的飞行员数量不足 $p_i$，那直接从源点向 $x_i$ 连一条容量为 $p_i$ 的边不就错了。可仔细想想，如果是这样（不足 $p_i$ )，那意味着前面的 $y_i$ 没有满流，已经属于 “No solution”了。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;const int MAXN = 1e3 + 10;const int MAXM = 1e5 + 10;const int INF = 0x3f3f3f3f;struct edge &#123; int to, cap, cost, next; edge( int to = 0, int cap = 0, int cost = 0, int next = 0 ) : to(to), cap(cap), cost(cost), next(next) &#123;&#125;&#125; G[MAXM &lt;&lt; 1];int n;int tot, head[MAXN];int d[MAXN], pre[MAXN];bool inque[MAXN];void init()&#123; tot = 0; memset(head, -1, sizeof(head));&#125;void add_edge(int u, int v, int cap, int cost)&#123; G[tot] = edge(v, cap, cost, head[u]); head[u] = tot++; G[tot] = edge(u, 0, -cost, head[v]); head[v] = tot++;&#125;bool spfa(int s, int t)&#123; memset(d, -1, sizeof(d)); memset(pre, -1, sizeof(pre)); memset(inque, 0, sizeof(inque)); queue&lt;int&gt; que; que.push(s); inque[s] = true; d[s] = 0; while( !que.empty() ) &#123; int u = que.front(); que.pop(); inque[u] = false; for( int i = head[u]; ~i; i = G[i].next ) &#123; edge &amp;e = G[i]; if( e.cap &gt; 0 &amp;&amp; (d[e.to] == -1 || d[e.to] &gt; d[u] + e.cost) ) &#123; d[e.to] = d[u] + e.cost; pre[e.to] = i; if( !inque[e.to] ) &#123; que.push(e.to); inque[e.to] = true; &#125; &#125; &#125; &#125; return ~d[t];&#125;int Min_Cost_Max_Flow(int s, int t, int &amp;cost)&#123; cost = 0; int f = 0; while( spfa(s, t) ) &#123; int Min = INF; for( int i = pre[t]; ~i; i = pre[G[i ^ 1].to] ) &#123; Min = min(Min, G[i].cap); &#125; for( int i = pre[t]; ~i; i = pre[G[i ^ 1].to] ) &#123; G[i].cap -= Min; G[i ^ 1].cap += Min; &#125; cost += d[t] * Min; f += Min; &#125; return f;&#125;int main()&#123; int T; scanf("%d", &amp;T); while( T-- ) &#123; init(); int k, m, P, Q; scanf("%d %d", &amp;n, &amp;k); int s = 0, t = 2 * n + 1; int p, sum = 0; add_edge(s, 1, k, 0); for( int i = 1; i &lt;= n; ++ i ) &#123; scanf("%d", &amp;p); sum += p; if( i &lt; n ) add_edge(i, i + 1, INF, 0); add_edge(i, t, p, 0); add_edge(s, n + i, p, 0); &#125; scanf("%d %d %d", &amp;m, &amp;P, &amp;Q); int x, y; for( int i = 0; i &lt; m; ++ i ) &#123; scanf("%d %d", &amp;x, &amp;y); for( int j = 1; j &lt;= n - y; ++ j ) &#123; add_edge(n + j, j + y, INF, x); &#125; &#125; for( int i = P; i &lt;= n; ++ i ) &#123; add_edge(s, i, INF, Q); &#125; int cost; int f = Min_Cost_Max_Flow(s, t, cost); if( f &lt; sum ) puts("No solution"); else printf("%d\n", cost); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZOJ 3760 Treasure Hunting（网络流）]]></title>
      <url>%2F2016%2F03%2F14%2Fzoj-3760%2F</url>
      <content type="text"><![CDATA[题目大意在2D平面上有 $N$ 个藏宝点，每个点的坐标为 $(x_i, y_i)$ ，价值为 $x_i$ $AND$ $y_i$ 。现要求选择权值和最大的一些点，且点集 $T$ 满足：$$ \forall(x_i, y_i)(x_j, y_j)(i \not= j) \in T, gcd(x_i \oplus y_i \oplus x_j \oplus y_j, P) &gt; 1 $$$P$ 是偶数，且 $\oplus$ 代表异或。求点集 $T$。$ (1 \le N \le 500, 2 \le P \le 10^{9}, 0 \le x_i, y_i \le 10^{9})$$ (\forall i, j, x_i \oplus y_i \oplus x_j \oplus y_j &gt; 0)$ 解题思路二分图最大点权独立集。 若直接根据点集条件将不满足条件的点连边，则无法确定是否是二分图，没办法进行建图求解。Ps: 一般图的最大点权独立集是NP困难的。考虑到这点，我们还是从题目入手，发现 $P$ 一定是偶数，我们分别计算 $x_i \oplus y_i$ 的值。由于奇数 $\oplus$ 奇数 $=$ 偶数， 偶数 $\oplus$ 偶数 $=$ 偶数， 奇数 $\oplus$ 偶数 $=$ 奇数，显然，不满足条件的边只能是第三种情况，否则gcd值至少为2。因此可证此图必是二分图（不可能有奇数环）。由此将 $x_i \oplus y_i$ 为奇数的当成 $X$ 集合，为偶数的当成 $Y$ 集合，直接跑网络流就可以了。（具体建图见下方知识扩展） 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;const int MAXN = 5e2 + 10;const int MAXM = 1e5 + 10;const int INF = 0x3f3f3f3f;struct edge &#123; int to, cap, next; edge( int to = 0, int cap = 0, int next = 0 ) : to(to), cap(cap), next(next) &#123;&#125;&#125; G[MAXM &lt;&lt; 1];int n, p;int x[MAXN], y[MAXN];int v[MAXN];int tot, head[MAXN], cur[MAXN];int d[MAXN];void add_edge(int u, int v, int cap)&#123; G[tot] = edge(v, cap, head[u]); head[u] = tot++; G[tot] = edge(u, 0, head[v]); head[v] = tot++;&#125;bool bfs(int s, int t)&#123; memset(d, -1, sizeof(d)); queue&lt;int&gt; que; que.push(s); d[s] = 0; while( !que.empty() ) &#123; int u = que.front(); que.pop(); for( int i = head[u]; ~i; i = G[i].next ) &#123; edge e = G[i]; if( e.cap &gt; 0 &amp;&amp; d[e.to] == -1 ) &#123; d[e.to] = d[u] + 1; que.push(e.to); &#125; &#125; &#125; return ~d[t];&#125;ll dfs(int u, int t, int f)&#123; if( u == t ) return f; ll sum = 0; for( int &amp;i = cur[u]; ~i; i = G[i].next ) &#123; edge e = G[i]; if( e.cap &gt; 0 &amp;&amp; d[e.to] == d[u] + 1 ) &#123; ll tmp = dfs(e.to, t, min(e.cap, f)); if( tmp &gt; 0 ) &#123; G[i].cap -= tmp; G[i ^ 1].cap += tmp; f -= tmp; sum += tmp; &#125; &#125; &#125; return sum;&#125;ll Dinic(int s, int t)&#123; ll sum = 0; while( bfs(s, t) ) &#123; memcpy(cur, head, sizeof(head)); sum += dfs(s, t, INF); &#125; return sum;&#125;int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125;void init()&#123; tot = 0; memset(head, -1, sizeof(head));&#125;int main()&#123; while( ~scanf("%d %d", &amp;n, &amp;p) ) &#123; init(); int s = 0, t = n + 1; ll ans = 0; for( int i = 1; i &lt;= n; ++ i ) &#123; scanf("%d %d", x + i, y + i); v[i] = x[i] ^ y[i]; ans += x[i] &amp; y[i]; if( v[i] &amp; 1 ) add_edge(s, i, x[i] &amp; y[i]); else add_edge(i, t, x[i] &amp; y[i]); &#125; for( int i = 1; i &lt;= n; ++ i ) &#123; for( int j = 1; j &lt; i; ++ j ) &#123; if( gcd(v[i] ^ v[j], p) &lt;= 1 ) &#123; if( v[i] &amp; 1 ) add_edge(i, j, INF); else add_edge(j, i, INF); &#125; &#125; &#125; printf("%lld\n", ans - Dinic(s, t)); &#125; return 0;&#125; 知识扩展二分图最大点权独立集 概念：给出一个二分图，每个结点上有一个非负权值。要求选出一些点，使得这些点之间没有边相连，且权值和最大。 做法：在二分图的基础上添加源点S和汇点T，然后从S向所有X集合中的点连一条边，所有Y集合中的点向T连一条边，容量均为该点的权值，X结点与Y结点之间的边的容量均为无穷大。这样，对于该图中的任意一个割，将割中的边对应的结点删掉就是一个符合要求的解，权和为所有权和减去割的容量。因此，只需要求出最小割，就能求出最大权和。 二分图最小点权覆盖集 概念：给出一个二分图，每个结点上有一个非负权值。要求选出一些点，使得这些点覆盖所有的边，且权值和最小。 做法：与求二分图最大点权独立集相同。最小点权覆盖集的总权值 ＋ 最大点权独立集的总权值 ＝ 图的总权值。 Brain Power若给出的点有负权值，那应该怎么求？ 显然对于二分图最大点权独立集来说，负权值的点没有意义，直接不考虑。那求二分图最小点权覆盖集时呢？ 头脑风暴下吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZOJ 3640 Help Me Escape（概率DP）]]></title>
      <url>%2F2016%2F03%2F13%2Fzoj-3640%2F</url>
      <content type="text"><![CDATA[题目大意Cain被困在一座有 $N$ 条路径的洞穴，他本身有战斗力为 $f$ 。每一天，Cain会被随机传送到某条路径：若他此时的战斗力大于该路径的困难度 $c_i$ ，那么他可以花费 $t_i$ 时间逃出这个洞穴；否则，无法逃出洞穴，但其战斗力可以增加 $c_i$ ，并等待第二天的传送。求Cain逃出洞穴的期望时间。 $( N \leq 100, f \leq 10000, c_i \leq 10000, 1 \leq i \leq N )$$( t_i = \lfloor \frac{1 + \sqrt{5}}{2} \rfloor \times c_i^{2} )$ 解题思路概率DP。 设 $dp[i][j]$ 表示Cain在第 $i$ 条路径，战斗力为 $j$ 时的期望时间。则其转移方程为$$ dp[i][j] = (\sum_{i=1}^n dp[i][j + c_i] + 1) / n (j \leq c_i) $$直接记忆化搜索就可以了。 注意其实还有一个优化，根据题意，无论Cain今天在哪条路径上，第二天被传送到任何一条路径的概率是相等的，也即他可能还会出现在今天这条路径上，所以上述转移方程的第一维其实是不需要的，只关注战斗力本身就可以了（详细请看代码）。 另外：由于本题的dp是double型，不能直接memset为某个值（可能会出现误差）， 可以考虑多增加一个数组判断是否访问或者直接手动对dp赋值。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;const int MAXN = 1e2 + 10;const int MAXM = 1e4 + 10;int n, f;int c[MAXN], t[MAXN];bool vis[MAXM];double dp[MAXM];double dfs(int cap)&#123; if( vis[cap] ) return dp[cap]; double &amp;v = dp[cap]; v = 0; for( int i = 0; i &lt; n; ++ i ) &#123; if( cap &gt; c[i] ) v += t[i]; else v += dfs(cap + c[i]) + 1; &#125; v /= n; return v;&#125;int main()&#123; while( ~scanf("%d %d", &amp;n, &amp;f) ) &#123; memset(vis, 0, sizeof(vis)); for( int i = 0; i &lt; n; ++ i ) &#123; scanf("%d", c + i); t[i] = int((1.0 + sqrt(5.0)) / 2 * c[i] * c[i]); &#125; printf("%.3f\n", dfs(f)); &#125; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F03%2F11%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
